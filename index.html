<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reproductor de TV Online (Smart TV - M3U)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* Estilos CSS con tema oscuro tipo Netflix/Smart TV */
        :root {
            --primary-color: #E50914; /* Rojo Netflix */
            --primary-color-hover: #b80710;
            --background-color: #141414;
            --text-color: #fff;
            --card-bg-start: #333;
            --card-bg-end: #222;
            --card-hover-bg-start: #444;
            --card-hover-bg-end: #333;
            --favorite-color: #ffd700;
            --border-radius-large: 15px;
            --border-radius-medium: 10px;
            --border-radius-small: 5px;
            --loading-color: var(--primary-color); /* Color para spinner */
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 0; padding: 0; background-color: var(--background-color);
            color: var(--text-color); overflow: hidden;
            text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        .header {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0));
            padding: 10px 20px; position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
            display: flex; justify-content: flex-start; align-items: center; height: 60px;
        }
        .header img { height: 50px; margin-right: 15px; }
        .container {
            display: flex; flex-direction: row; position: fixed; top: 60px; left: 0; right: 0; bottom: 0;
            padding: 10px; background-color: var(--background-color); gap: 10px;
        }
        #player-container {
            flex: 3; position: relative; border-radius: var(--border-radius-medium); overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); background-color: #000;
            transition: flex 0.3s ease, margin-right 0.3s ease;
        }
        #my-video {
            width: 100%; height: 100%; object-fit: contain; border-radius: var(--border-radius-medium); background-color: #000;
        }
        #playlist-container {
            flex: 1; background-color: var(--background-color); border-radius: var(--border-radius-medium);
            padding: 15px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); overflow-y: auto;
            display: flex; flex-direction: column; min-width: 280px; max-width: 320px;
            transition: opacity 0.3s ease, transform 0.3s ease, min-width 0.3s ease, max-width 0.3s ease, padding 0.3s ease, flex 0.3s ease, margin-left 0.3s ease;
            opacity: 1; transform: translateX(0); position: relative; /* Para loading */
        }
        .playlist-hidden #playlist-container {
            opacity: 0; transform: translateX(100%); min-width: 0; max-width: 0; padding: 0;
            overflow: hidden; flex: 0; margin-left: -10px;
        }
        .playlist-hidden #player-container { flex: 1; margin-right: 0; }
        #playlist-container h2 { margin-top: 0; margin-bottom: 10px; text-align: center; font-size: 1.1em; flex-shrink: 0; }
        #search {
            width: calc(100% - 22px); padding: 8px; margin: 0 auto 10px auto; display: block;
            border-radius: var(--border-radius-small); border: 1px solid var(--card-bg-start);
            background-color: var(--card-bg-end); color: var(--text-color); font-size: 0.9em; flex-shrink: 0;
        }
        #search::placeholder { color: #ccc; }
        #search:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 4px rgba(229, 9, 20, 0.4); }
        #playlist {
            list-style-type: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: var(--primary-color) var(--card-bg-end); scroll-behavior: smooth;
        }
        #playlist::-webkit-scrollbar { width: 8px; }
        #playlist::-webkit-scrollbar-track { background: var(--card-bg-end); border-radius: 4px;}
        #playlist::-webkit-scrollbar-thumb { background-color: var(--primary-color); border-radius: 4px; border: 2px solid var(--card-bg-end);}
        #playlist li {
            display: flex; justify-content: space-between; align-items: center; cursor: default;
            padding: 6px 10px; margin-bottom: 4px; background: linear-gradient(145deg, var(--card-bg-start), var(--card-bg-end));
            border-radius: var(--border-radius-medium); transition: background 0.2s ease-in-out; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        #playlist li:hover .channel-button { background-color: rgba(255, 255, 255, 0.05); }
        .channel-info { display: flex; align-items: center; gap: 10px; overflow: hidden; }
        .channel-info img { width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0; object-fit: cover; border: 1px solid rgba(255, 255, 255, 0.1); }
        .channel-details { overflow: hidden; }
        .channel-title { font-size: 0.9em; font-weight: 500; color: var(--text-color); display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; line-height: 1.3; }
        .channel-desc { font-size: 0.7em; color: #bbb; margin: 1px 0 0 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .star { cursor: pointer; color: #ccc; transition: color 0.2s ease, transform 0.2s ease; font-size: 0.9em; flex-shrink: 0; padding: 4px; }
        .star:hover { transform: scale(1.1); }
        .star.favorite { color: var(--favorite-color); }
        .star.favorite:hover { color: #e6c300; }
        .channel-button { background: none; border: none; padding: 0; margin: 0; color: inherit; font: inherit; text-align: left; cursor: pointer; display: block; width: 100%; flex-grow: 1; margin-right: 8px; border-radius: var(--border-radius-small); outline: none; transition: background-color 0.2s ease; }
        .channel-button:focus { background-color: rgba(229, 9, 20, 0.3); box-shadow: inset 0 0 0 2px var(--primary-color); border-radius: var(--border-radius-medium); }
        .star:focus { outline: 2px solid var(--favorite-color); outline-offset: 1px; border-radius: 50%; }
        .error-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; color: white; text-align: center; padding: 20px; display: none; }
        .error-message { font-size: 1.1em; margin-bottom: 15px; }
        .error-buttons { display: flex; gap: 10px; }
        .error-button { padding: 8px 15px; background-color: var(--primary-color); border: none; border-radius: 5px; color: white; cursor: pointer; transition: background-color 0.2s ease; }
        .error-button:hover, .error-button:focus { background-color: var(--primary-color-hover); outline: none; box-shadow: 0 0 5px rgba(255,255,255,0.5); }
        /* Loading Indicator */
        .loading-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1em;
            color: var(--text-color); display: none; flex-direction: column; align-items: center; gap: 10px; z-index: 5;
        }
        .loading-indicator.show { display: flex; }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2); border-top: 4px solid var(--loading-color); border-radius: 50%;
            width: 30px; height: 30px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="playlist-visible">
    <header class="header">
        <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgVIFxWI-sdOR2bVfpbgCotXquColWskv4u4I9HXZhYdsRewDVRNcJ7iLvtKO2xYucvqOv0DKY2MArMnHGF8IvZBI7NYjg0dkjHUN0N8VXwZ73vKjYOajWC6JTze5n1Hcj19V2COVFkN-TtJA7uR_ALIYyIcvUBOwQN1EmURskiBCI_lJK3hFphdSBuCaQ/w547-h320/logo%20(%20JORGEDEZ%20)%20ROJO%20Y%20BLANCO%20PARA%20VIDEO.jpeg" alt="JORGEDEZ Logo">
    </header>

    <div class="container">
        <div id="player-container">
            <video id="my-video" controls playsinline webkit-playsinline crossorigin="anonymous">
                <source src="" type="application/x-mpegURL">
                Tu navegador no soporta el elemento de video.
            </video>
        </div>

        <div id="playlist-container">
            <div class="loading-indicator" id="loading-indicator">
                <div class="spinner"></div>
                <span>Cargando...</span>
            </div>
            <h2>Lista de reproducción</h2>
            <input type="text" id="search" placeholder="Buscar canal..." disabled>
            <ul id="playlist">
                </ul>
        </div>
    </div>

    <div class="error-overlay" id="error-overlay">
        <div class="error-message" id="error-message">No se pudo cargar el canal. Intente con otro.</div>
        <div class="error-buttons">
            <button class="error-button" id="try-again-button">Intentar nuevamente</button>
            <button class="error-button" id="try-another-button">Probar otro canal</button>
            <button class="error-button" id="reload-list-button" style="display: none;">Recargar Lista</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Reproductor SmartTV: DOM Cargado.");

            // --- !!! URL de tu archivo M3U !!! ---
            const m3uUrl = 'https://raw.githubusercontent.com/sejo48/chanejorgedez/refs/heads/main/listaoficial.m3u'; // <-- TU URL AQUÍ

            // --- Globales ---
            let channels = []; // Se llenará desde M3U
            let favorites = JSON.parse(localStorage.getItem('favoritesTvChannels')) || [];
            let currentChannelIndex = -1;
            let hls = null;
            let isPlaylistVisible = true;

            // --- DOM Elements ---
            const bodyElement = document.body;
            const videoPlayer = document.getElementById('my-video');
            const playlistElement = document.getElementById('playlist');
            const searchInput = document.getElementById('search');
            const playerContainer = document.getElementById('player-container');
            const playlistContainer = document.getElementById('playlist-container');
            const errorOverlay = document.getElementById('error-overlay');
            const errorMessage = document.getElementById('error-message');
            const tryAgainButton = document.getElementById('try-again-button');
            const tryAnotherButton = document.getElementById('try-another-button');
            const reloadListButton = document.getElementById('reload-list-button');
            const loadingIndicator = document.getElementById('loading-indicator');

            // --- Loading Indicator ---
            function showLoading(message = "Cargando...") {
                if (loadingIndicator) {
                    loadingIndicator.querySelector('span').textContent = message;
                    loadingIndicator.classList.add('show');
                }
                searchInput.disabled = true;
                playlistElement.innerHTML = ''; // Limpiar lista mientras carga
            }
            function hideLoading() {
                if (loadingIndicator) {
                    loadingIndicator.classList.remove('show');
                }
                searchInput.disabled = false;
            }

            // --- M3U Parsing Function (Lógica de Título Corregida) ---
            async function fetchAndParseM3U(url) {
                showLoading("Cargando lista M3U...");
                console.log(`Reproductor SmartTV: Buscando M3U desde: ${url}`);
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Error HTTP: ${response.status}`);
                    }
                    const m3uText = await response.text();
                    console.log("Reproductor SmartTV: M3U obtenido.");

                    const lines = m3uText.split(/[\r\n]+/);
                    const parsedChannels = [];
                    let currentChannelInfo = null;

                    const extinfRegex = /#EXTINF:(-?\d+)(.*)/;
                    const attributeRegex = /(\S+?)=(?:"([^"]*)"|([^ ]*))/g;
                    const titleCommaRegex = /,(?!")(.*)/;

                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (!trimmedLine || trimmedLine.startsWith('#EXTM3U')) continue; // Ignorar vacías y cabecera

                        if (trimmedLine.startsWith('#EXTINF:')) {
                            const match = trimmedLine.match(extinfRegex);
                            if (match) {
                                currentChannelInfo = { duration: match[1], attributes: {}, title: '', logo: '', url: '', descripcion: '' };
                                const restOfLine = match[2] || '';
                                let attrMatch;
                                while ((attrMatch = attributeRegex.exec(restOfLine)) !== null) {
                                    const key = attrMatch[1].toLowerCase();
                                    const value = attrMatch[2] !== undefined ? attrMatch[2] : attrMatch[3];
                                    currentChannelInfo.attributes[key] = value;
                                }
                                if (currentChannelInfo.attributes['tvg-name']) {
                                    currentChannelInfo.title = currentChannelInfo.attributes['tvg-name'].trim();
                                }
                                if (!currentChannelInfo.title) {
                                    const titleMatch = restOfLine.match(titleCommaRegex);
                                    if (titleMatch && titleMatch[1]) {
                                        currentChannelInfo.title = titleMatch[1].trim();
                                    }
                                }
                                if (!currentChannelInfo.title) { currentChannelInfo.title = 'Sin Título'; }
                                currentChannelInfo.logo = currentChannelInfo.attributes['tvg-logo'] || '';
                                currentChannelInfo.descripcion = `Canal: ${currentChannelInfo.title}`; // Descripción simple
                            } else {
                                console.warn("Línea #EXTINF no reconocida:", trimmedLine);
                                currentChannelInfo = null;
                            }
                        } else if (currentChannelInfo && trimmedLine && !trimmedLine.startsWith('#')) {
                            currentChannelInfo.url = trimmedLine;
                            if (currentChannelInfo.url) {
                                parsedChannels.push(currentChannelInfo);
                            } else {
                                console.warn("Saltando canal sin URL:", currentChannelInfo.title);
                            }
                            currentChannelInfo = null;
                        }
                    }
                    console.log(`Reproductor SmartTV: Parseados ${parsedChannels.length} canales.`);
                    if (parsedChannels.length === 0 && lines.length > 1) {
                         showM3UError("No se encontraron canales válidos en el archivo M3U.");
                         return [];
                    }
                    return parsedChannels;
                } catch (error) {
                    console.error('Reproductor SmartTV: Error cargando o parseando M3U:', error);
                    showM3UError(`Error al cargar la lista M3U: ${error.message}. Verifica la URL e inténtalo de nuevo.`);
                    return [];
                } finally {
                    hideLoading();
                }
            }

            // --- Show M3U Loading Error ---
            function showM3UError(message) {
                 errorMessage.textContent = message;
                 errorOverlay.style.display = 'flex';
                 tryAgainButton.style.display = 'none'; // Ocultar botones irrelevantes
                 tryAnotherButton.style.display = 'none';
                 reloadListButton.style.display = 'inline-block'; // Mostrar botón de recarga
                 setTimeout(() => reloadListButton.focus(), 100); // Enfocar botón
            }

            // --- Error Handling (Playback) ---
            function showError(message, channelIndexToShow = -1) {
                currentChannelIndex = channelIndexToShow; // Guardar índice que falló
                errorMessage.textContent = message;
                errorOverlay.style.display = 'flex';
                tryAgainButton.style.display = 'inline-block'; // Mostrar botones relevantes
                tryAnotherButton.style.display = 'inline-block';
                reloadListButton.style.display = 'none'; // Ocultar recarga M3U
                setTimeout(() => tryAgainButton.focus(), 100); // Enfocar botón
                if (hls) { hls.stopLoad(); }
                videoPlayer.pause();
                console.error("Error mostrado (Playback):", message, "Canal:", channelIndexToShow !== -1 ? channels[channelIndexToShow]?.title : 'N/A');
            }
            function hideError() {
                errorOverlay.style.display = 'none';
                if (isPlaylistVisible) { focusCurrentOrFirstChannel(); }
            }

            // Error Button Listeners
            tryAgainButton.addEventListener('click', () => {
                hideError();
                if (currentChannelIndex !== -1 && currentChannelIndex >= 0 && currentChannelIndex < channels.length) {
                    selectChannel(currentChannelIndex);
                } else { focusCurrentOrFirstChannel(); }
            });
            tryAnotherButton.addEventListener('click', () => {
                hideError();
                if (!isPlaylistVisible) { showPlaylist(); }
                else { focusCurrentOrFirstChannel(); }
            });
            reloadListButton.addEventListener('click', () => { // Listener para recargar M3U
                 hideError();
                 initializeApp(); // Re-inicializar
             });

            // --- Playlist Visibility ---
            function showPlaylist() { /* (sin cambios) */
                bodyElement.classList.remove('playlist-hidden'); bodyElement.classList.add('playlist-visible');
                isPlaylistVisible = true; focusCurrentOrFirstChannel();
            }
            function hidePlaylist() { /* (sin cambios) */
                bodyElement.classList.add('playlist-hidden'); bodyElement.classList.remove('playlist-visible');
                isPlaylistVisible = false;
            }
            function togglePlaylist() { if (isPlaylistVisible) hidePlaylist(); else showPlaylist(); }

            // --- Playlist Rendering ---
             function renderPlaylist(channelsToRender = channels) {
                console.log(`Reproductor SmartTV: Renderizando ${channelsToRender.length} canales.`);
                playlistElement.innerHTML = '';
                if (!channelsToRender || channelsToRender.length === 0) {
                    console.log("Reproductor SmartTV: No hay canales para renderizar.");
                    return; // Salir si no hay canales
                }

                // Ordenar: Favoritos primero, luego por índice original
                const sortedChannels = [...channelsToRender].sort((a, b) => {
                    const aIndex = channels.findIndex(ch => ch.url === a.url); // Índice original global
                    const bIndex = channels.findIndex(ch => ch.url === b.url);
                    const aIsFavorite = favorites.includes(aIndex.toString());
                    const bIsFavorite = favorites.includes(bIndex.toString());
                    if (aIsFavorite && !bIsFavorite) return -1;
                    if (!aIsFavorite && bIsFavorite) return 1;
                    return aIndex - bIndex; // Mantener orden original si no son favoritos
                });

                sortedChannels.forEach((channel) => {
                    const originalIndex = channels.findIndex(ch => ch.url === channel.url);
                    if (originalIndex === -1) return; // Canal no encontrado en la lista original

                    const li = document.createElement('li');
                    li.dataset.originalIndex = originalIndex;

                    const channelButton = document.createElement('button');
                    channelButton.classList.add('channel-button');
                    channelButton.type = 'button';
                    const safeTitle = (channel.title || 'Canal sin título').replace(/"/g, '&quot;');
                    const logoSrc = channel.logo || `https://placehold.co/56x56/222/fff?text=${encodeURIComponent(safeTitle.charAt(0))}`;

                    channelButton.innerHTML = `
                        <div class="channel-info">
                            <img src="${logoSrc}" alt="${safeTitle}" onerror="this.onerror=null; this.src='https://placehold.co/56x56/222/fff?text=${encodeURIComponent(safeTitle.charAt(0))}';">
                            <div class="channel-details">
                                <span class="channel-title">${safeTitle}</span>
                                <p class="channel-desc">${channel.descripcion || ''}</p>
                            </div>
                        </div>`;
                    channelButton.addEventListener('click', () => {
                        selectChannel(originalIndex);
                        hidePlaylist(); // Ocultar lista al seleccionar
                    });
                    li.appendChild(channelButton);

                    const star = document.createElement('i');
                    const isFav = favorites.includes(originalIndex.toString());
                    star.className = `star fas fa-star ${isFav ? 'favorite' : ''}`;
                    star.dataset.index = originalIndex;
                    star.tabIndex = 0; // Hacer enfocable
                    star.setAttribute('role', 'button');
                    star.setAttribute('aria-label', `${isFav ? 'Quitar' : 'Marcar'} ${safeTitle} como favorito`);

                    star.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFavorite(originalIndex.toString());
                        const currentSearchTerm = searchInput.value.toLowerCase();
                        filterAndRender(currentSearchTerm); // Re-renderizar para mostrar cambio
                    });
                    star.addEventListener('keydown', handleStarKeydown); // Usar handler separado

                    li.appendChild(star);
                    playlistElement.appendChild(li);
                });
            }

            function filterAndRender(searchTerm) {
                 const filtered = channels.filter(channel =>
                     (channel.title && channel.title.toLowerCase().includes(searchTerm)) ||
                     (channel.descripcion && channel.descripcion.toLowerCase().includes(searchTerm))
                 );
                 renderPlaylist(filtered);
                 // No re-enfocar automáticamente al filtrar para no interrumpir escritura
            }

            // --- Focus Management & Centered Scrolling ---
            function scrollToCenter(element) { /* (sin cambios) */
                if (!element || !playlistElement) return;
                const elementRect = element.getBoundingClientRect();
                const playlistRect = playlistElement.getBoundingClientRect();
                const desiredTop = playlistRect.height / 2 - elementRect.height / 2;
                const elementOffsetTop = element.offsetTop;
                const targetScrollTop = elementOffsetTop - desiredTop;
                playlistElement.scrollTo({ top: targetScrollTop, behavior: 'smooth' });
            }
            function focusAndScrollToCenter(element) { /* (sin cambios) */
                if(element) { element.focus({ preventScroll: true }); scrollToCenter(element.closest('li')); }
            }
            function focusChannelButtonByIndex(index) { /* (sin cambios) */
                const targetLi = playlistElement.querySelector(`li[data-original-index="${index}"]`);
                if (targetLi) {
                    const targetButton = targetLi.querySelector('.channel-button');
                    if (targetButton) { focusAndScrollToCenter(targetButton); return true; }
                } return false;
            }
            function focusFirstVisibleChannel() { /* (sin cambios) */
                const firstButton = playlistElement.querySelector('.channel-button');
                if (firstButton) { focusAndScrollToCenter(firstButton); return true; }
                searchInput.focus(); return false;
            }
            function focusCurrentOrFirstChannel() { /* (sin cambios) */
                if (!isPlaylistVisible) return;
                if (currentChannelIndex !== -1) { if (focusChannelButtonByIndex(currentChannelIndex)) { return; } }
                focusFirstVisibleChannel();
            }
            function navigateListFocus(direction) { /* (sin cambios) */
                if (!isPlaylistVisible) return;
                const focusableElements = Array.from(playlistContainer.querySelectorAll('#search, #playlist .channel-button'));
                if (focusableElements.length === 0) return;
                let currentFocusIndex = -1;
                if (document.activeElement.id === 'search') { currentFocusIndex = 0; }
                else { const activeLi = document.activeElement.closest('li'); const buttonInActiveLi = activeLi?.querySelector('.channel-button');
                    if (buttonInActiveLi) { currentFocusIndex = focusableElements.findIndex(el => el === buttonInActiveLi); }
                    else { currentFocusIndex = focusableElements.findIndex(el => el === document.activeElement); }
                }
                let nextFocusIndex;
                if (currentFocusIndex === -1) { nextFocusIndex = direction > 0 ? 0 : focusableElements.length - 1; }
                else { nextFocusIndex = (currentFocusIndex + direction + focusableElements.length) % focusableElements.length; }
                const nextElement = focusableElements[nextFocusIndex];
                if (nextElement) { if(nextElement.id === 'search') { nextElement.focus(); } else { focusAndScrollToCenter(nextElement); } }
            }

             // ** NUEVO ** Handler específico para teclas en la estrella
             function handleStarKeydown(e) {
                 const originalIndex = e.target.dataset.index;
                 if (!originalIndex) return;

                 if (e.key === 'Enter' || e.key === 'Ok') {
                     e.preventDefault(); e.stopPropagation();
                     toggleFavorite(originalIndex);
                     const currentSearchTerm = searchInput.value.toLowerCase();
                     filterAndRender(currentSearchTerm);
                     setTimeout(() => { // Re-enfocar botón después de renderizar
                         const liElement = playlistElement.querySelector(`li[data-original-index="${originalIndex}"]`);
                         const buttonToFocus = liElement?.querySelector('.channel-button');
                         if (buttonToFocus) focusAndScrollToCenter(buttonToFocus);
                     }, 50);
                 } else if (e.key === 'ArrowLeft') {
                     e.preventDefault(); e.stopPropagation();
                     const button = e.target.closest('li')?.querySelector('.channel-button');
                     if (button) focusAndScrollToCenter(button);
                 } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                     e.preventDefault(); e.stopPropagation();
                     navigateListFocus(e.key === 'ArrowUp' ? -1 : 1); // Navegar a botón de otro item
                 }
                 // Ignorar ArrowRight en la estrella
             }

            // --- Channel Selection and Playback ---
            function selectChannel(index) { /* (sin cambios) */
                if (index < 0 || index >= channels.length) { console.error("Índice inválido:", index); return; }
                hideError(); console.log(`Seleccionando canal ${index}: ${channels[index].title}`);
                playVideo(channels[index].url, index);
                localStorage.setItem('lastPlayedTvChannel', index.toString());
                currentChannelIndex = index;
            }
            function playVideo(url, channelIndex) { /* (sin cambios) */
                console.log(`Intentando reproducir canal ${channelIndex}: ${channels[channelIndex].title} (${url})`);
                currentChannelIndex = channelIndex; // Actualizar índice actual
                if (hls) { hls.destroy(); hls = null; }
                videoPlayer.removeAttribute('src'); videoPlayer.load();
                videoPlayer.removeEventListener('error', handleVideoElementError);

                if (!url || typeof url !== 'string' || url.trim() === '') {
                    showError("URL inválida o faltante para este canal.", channelIndex); return;
                }

                const isM3U8 = url.includes('.m3u8') || url.includes('mpegurl');
                if (Hls.isSupported() && isM3U8) {
                    console.log("Usando HLS.js"); hls = new Hls();
                    hls.on(Hls.Events.ERROR, function(event, data) { console.error('HLS Error:', data); if (data.fatal) { let errorMsg = `Error HLS (${data.details}).`; /*...*/ showError(errorMsg, channelIndex); if (hls) { hls.destroy(); hls = null; } } });
                    hls.loadSource(url); hls.attachMedia(videoPlayer);
                    hls.on(Hls.Events.MANIFEST_PARSED, function() { console.log("Manifiesto HLS parseado."); videoPlayer.play().catch(e => console.warn("Fallo Play() HLS:", e)); });
                } else if (isM3U8 && (videoPlayer.canPlayType('application/vnd.apple.mpegurl') || videoPlayer.canPlayType('application/x-mpegURL'))) {
                    console.log("Usando HLS nativo"); videoPlayer.src = url;
                    videoPlayer.addEventListener('error', handleVideoElementError);
                    videoPlayer.addEventListener('loadedmetadata', () => { console.log("Metadatos cargados (nativo)."); videoPlayer.play().catch(e => console.warn("Fallo Play() nativo:", e)); }, { once: true });
                } else if (!isM3U8) { // Intentar reproducir directo si no es M3U8
                     console.log("Intentando reproducción directa (no M3U8)");
                     videoPlayer.src = url;
                     videoPlayer.addEventListener('error', handleVideoElementError);
                     videoPlayer.addEventListener('loadeddata', () => { console.log("Datos cargados (directo)."); videoPlayer.play().catch(e => console.warn("Fallo Play() directo:", e)); }, { once: true });
                } else {
                    console.error("HLS no soportado o URL M3U8 inválida.");
                    showError("Formato M3U8 no soportado por este navegador.", channelIndex);
                }
            }
            function handleVideoElementError() { /* (sin cambios) */
                const error = videoPlayer.error; console.error("Error en <video>:", error);
                let message = "Error desconocido."; if (error) { /*...*/ }
                if (!errorOverlay.style.display || errorOverlay.style.display === 'none') { showError(message, currentChannelIndex); }
                if (hls) { hls.destroy(); hls = null; }
            }

            // --- Favorites Management ---
            function toggleFavorite(indexString) { /* (sin cambios) */
                const index = parseInt(indexString); if (isNaN(index)) return;
                const indexInFavorites = favorites.indexOf(indexString);
                if (indexInFavorites > -1) { favorites.splice(indexInFavorites, 1); } else { favorites.push(indexString); }
                localStorage.setItem('favoritesTvChannels', JSON.stringify(favorites));
                console.log("Favoritos actualizados:", favorites);
            }

            // --- Volume Control ---
            function adjustVolume(delta) { /* (sin cambios) */
                let newVolume = Math.max(0, Math.min(1, +(videoPlayer.volume + delta).toFixed(2)));
                videoPlayer.volume = newVolume; videoPlayer.muted = false;
                console.log(`Volumen: ${Math.round(newVolume * 100)}%`);
            }
            playerContainer.addEventListener('wheel', (event) => { /* (sin cambios) */
                if (event.ctrlKey) { event.preventDefault(); const delta = event.deltaY > 0 ? -0.1 : 0.1; adjustVolume(delta); }
            }, { passive: false });

            // --- Fullscreen ---
             function toggleFullscreen() { /* (sin cambios) */
                 if (!document.fullscreenElement) { playerContainer.requestFullscreen().catch(err => console.error(`Error FS: ${err.message}`)); }
                 else { document.exitFullscreen(); }
             }

            // --- Keyboard / Remote Control Handling ---
            document.addEventListener('keydown', (event) => { /* (Revisado y simplificado ligeramente, lógica principal sin cambios) */
                if (document.activeElement === searchInput) { /* ... manejo search ... */ return; }
                if (errorOverlay.style.display === 'flex' && errorOverlay.contains(document.activeElement)) { /* ... manejo error overlay ... */ if (event.key !== 'Backspace' && event.key !== 'Back' && event.key !== 'Enter' && event.key !== 'Ok') { event.preventDefault(); return; } }

                let preventDefault = true;
                const activeElementIsButton = document.activeElement.classList.contains('channel-button');
                const activeElementIsStar = document.activeElement.classList.contains('star');

                switch (event.key) {
                    case ' ': case 'MediaPlayPause': togglePlayPause(); break;
                    case 'MediaStop': videoPlayer.pause(); videoPlayer.currentTime = 0; break;
                    case 'm': case 'M': videoPlayer.muted = !videoPlayer.muted; break;
                    case 'f': case 'F': toggleFullscreen(); break;
                    case 'Enter': case 'Ok': if (isPlaylistVisible) { if (activeElementIsButton) { document.activeElement.click(); } else if (activeElementIsStar) { preventDefault = false; } else { hidePlaylist(); } } else { showPlaylist(); } break;
                    case 'ArrowUp': if (isPlaylistVisible) { navigateListFocus(-1); } else { adjustVolume(0.1); } break;
                    case 'ArrowDown': if (isPlaylistVisible) { navigateListFocus(1); } else { adjustVolume(-0.1); } break;
                    case 'ArrowRight': if (!isPlaylistVisible) { videoPlayer.currentTime += 10; } else { if (activeElementIsButton) { const star = document.activeElement.closest('li')?.querySelector('.star'); if (star) focusAndScrollToCenter(star); } else { preventDefault = false; } } break;
                    case 'ArrowLeft': if (!isPlaylistVisible) { videoPlayer.currentTime -= 10; } else { if (activeElementIsStar) { const button = document.activeElement.closest('li')?.querySelector('.channel-button'); if (button) focusAndScrollToCenter(button); } else { preventDefault = false; } } break;
                    case 'Backspace': case 'Back': if (errorOverlay.style.display === 'flex') { hideError(); } else if (document.fullscreenElement) { document.exitFullscreen(); } else if (isPlaylistVisible) { hidePlaylist(); } else { preventDefault = false; } break;
                    default: preventDefault = false; break;
                }
                if (preventDefault) { event.preventDefault(); }
            });

            // --- Search Functionality ---
            searchInput.addEventListener('input', (e) => { filterAndRender(e.target.value.toLowerCase()); });

            // --- Initialization Function ---
            async function initializeApp() {
                console.log("Reproductor SmartTV: Inicializando app...");
                channels = await fetchAndParseM3U(m3uUrl); // Cargar canales
                renderPlaylist(); // Renderizar la lista obtenida

                if (channels.length > 0) {
                    const lastPlayedIndexStr = localStorage.getItem('lastPlayedTvChannel');
                    let initialChannelIndex = 0;
                    if (lastPlayedIndexStr !== null) {
                        const lastPlayedIndex = parseInt(lastPlayedIndexStr);
                        if (!isNaN(lastPlayedIndex) && lastPlayedIndex >= 0 && lastPlayedIndex < channels.length) {
                            initialChannelIndex = lastPlayedIndex;
                        } else { localStorage.removeItem('lastPlayedTvChannel'); }
                    }
                    currentChannelIndex = initialChannelIndex;
                    console.log(`Reproductor SmartTV: Índice inicial: ${currentChannelIndex} (${channels[currentChannelIndex]?.title})`);
                    // Enfocar el primer canal o el último reproducido al inicio
                    setTimeout(() => { focusCurrentOrFirstChannel(); }, 100);
                    // Opcional: auto-reproducir y ocultar lista
                    // selectChannel(initialChannelIndex);
                    // hidePlaylist();
                } else {
                    console.warn("Reproductor SmartTV: No se cargaron canales.");
                    // El error ya se mostró desde fetchAndParseM3U si falló la carga
                }
                 console.log("Reproductor SmartTV: Inicialización completada.");
            }

            // --- Start the application ---
            initializeApp();

        }); // End DOMContentLoaded
    </script>
</body>
</html>
