<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reproductor Smart TV M3U v14.2</title> <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        /* --- CSS Variables --- */
        :root {
            --primary-bg: #121212; /* Dark background */
            --secondary-bg: #1e1e1e; /* Slightly lighter background for sidebar */
            --tertiary-bg: #2a2a2a; /* Background for dividers, hover states */
            --text-color: #e0e0e0; /* Main text color */
            --text-secondary-color: #b3b3b3; /* Secondary text color (channel names) */
            --highlight-color: #1DB954; /* Highlight color (selected channel) */
            --favorite-color: #FFD700; /* Color for favorite icon */
            /* --- MODIFICACIÓN: Sidebar más estrecha --- */
            --sidebar-width: 240px; /* Ancho reducido */
            --border-radius: 4px; /* Standard border radius */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; /* System font stack */
            --transition-speed: 0.4s; /* Faster transition */
            --timing-function: cubic-bezier(0.645, 0.045, 0.355, 1.000); /* Ease-in-out-cubic like */
        }

        /* --- Reset and Globals --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; background-color: var(--primary-bg); color: var(--text-color); font-family: var(--font-family); }
        .player-container { display: flex; height: 100%; width: 100%; position: relative; overflow: hidden; }

        /* --- Sidebar --- */
        #sidebar {
            width: var(--sidebar-width);
            min-width: var(--sidebar-width); /* Prevent shrinking below initial width */
            background-color: var(--secondary-bg);
            height: 100%;
            overflow: hidden; /* Hide content during transition */
            transition: transform var(--transition-speed) var(--timing-function),
                        width var(--transition-speed) var(--timing-function),
                        min-width var(--transition-speed) var(--timing-function),
                        padding var(--transition-speed) var(--timing-function),
                        border var(--transition-speed) var(--timing-function);
            z-index: 10;
            border-right: 1px solid var(--tertiary-bg);
            display: flex;
            flex-direction: column;
            flex-shrink: 0; /* Prevent sidebar from shrinking when content grows */
        }
        #sidebar.hidden {
            transform: translateX(-100%); width: 0; min-width: 0; padding: 0; border: none; overflow: hidden;
        }

        /* --- Sidebar Header --- */
        .sidebar-header {
            padding: 10px 15px; border-bottom: 1px solid var(--tertiary-bg);
            transition: padding var(--transition-speed) var(--timing-function), border var(--transition-speed) var(--timing-function), height var(--transition-speed) var(--timing-function), opacity var(--transition-speed) var(--timing-function);
            display: flex; align-items: center; justify-content: center; gap: 10px; height: 70px; opacity: 1; flex-shrink: 0; /* Prevent header from shrinking */
        }
        #sidebar.hidden .sidebar-header { padding: 0; border: none; height: 0; opacity: 0; overflow: hidden; }
        .app-logo { max-width: 70%; max-height: 40px; object-fit: contain; display: block; }
        .channel-count { background-color: var(--tertiary-bg); color: var(--text-color); font-size: 0.75em; font-weight: bold; border-radius: 50%; width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; line-height: 1; flex-shrink: 0; transition: opacity var(--transition-speed) var(--timing-function); }
        #sidebar.hidden .channel-count { opacity: 0; }

        /* --- Channel List --- */
        .channel-list-container { flex-grow: 1; overflow-y: auto; transition: opacity var(--transition-speed) var(--timing-function); }
        #sidebar.hidden .channel-list-container { opacity: 0; }

        /* --- VISUAL IMPROVEMENT 6: Custom Scrollbar --- */
        .channel-list-container::-webkit-scrollbar { width: 10px; }
        .channel-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 5px; }
        .channel-list-container::-webkit-scrollbar-thumb { background-color: var(--tertiary-bg); border-radius: 5px; border: 2px solid var(--secondary-bg); /* Border matching background for 'floating' effect */ }
        .channel-list-container::-webkit-scrollbar-thumb:hover { background-color: #555; }
        .channel-list { list-style: none; padding: 0; }

        /* --- Channel Item --- */
        .channel-item {
            display: flex; align-items: center;
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--tertiary-bg);
            transition: background-color 0.15s ease-out, color 0.15s ease-out;
            font-size: 0.95em;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            color: var(--text-secondary-color);
            position: relative; /* Needed for absolute positioning of favorite button */
        }
        .channel-item:last-child { border-bottom: none; }
        .channel-logo { width: 32px; height: 32px; margin-right: 12px; object-fit: contain; flex-shrink: 0; background-color: rgba(255, 255, 255, 0.1); border-radius: var(--border-radius); vertical-align: middle; }
        .channel-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; margin-right: 30px; /* Space for favorite button */ }
        .channel-item:hover, .channel-item:focus { background-color: var(--tertiary-bg); color: var(--text-color); outline: none; }
        .channel-item.selected { background-color: var(--highlight-color); font-weight: bold; color: var(--primary-bg); }
        .channel-item.selected .channel-name { color: var(--primary-bg); } /* Ensure text is readable when selected */
        .channel-item.selected:hover { background-color: #1aa34a; } /* Slightly darker highlight on hover */

        /* --- Favorite Button --- */
        .favorite-btn {
            position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
            background: none; border: none; cursor: pointer; padding: 5px;
            display: flex; align-items: center; justify-content: center;
            opacity: 0.6; transition: opacity 0.2s ease, color 0.2s ease;
        }
        .favorite-btn svg { width: 18px; height: 18px; fill: var(--text-secondary-color); transition: fill 0.2s ease; }
        /* Show favorite button on hover/focus or if it's already favorited */
        .channel-item:hover .favorite-btn,
        .channel-item:focus .favorite-btn,
        .channel-item .favorite-btn.is-favorite { opacity: 1; }
        .favorite-btn.is-favorite svg { fill: var(--favorite-color); }
        /* Adjust favorite icon color when item is selected */
        .channel-item.selected .favorite-btn svg { fill: var(--primary-bg); opacity: 0.8; }
        .channel-item.selected .favorite-btn.is-favorite svg { fill: var(--favorite-color); opacity: 1; }

        /* --- Main Content (Player) --- */
        .player-content {
            flex-grow: 1; height: 100%; display: flex; flex-direction: column; position: relative; background-color: #000;
            /* Subtle pattern for the background */
            background-image: repeating-linear-gradient( 45deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.02) 1px, transparent 1px, transparent 10px );
        }
        #videoPlayer { width: 100%; height: 100%; flex-grow: 1; background-color: transparent; display: block; object-fit: contain; outline: none; }

        /* --- Channel Info & Loader --- */
        .channel-info { position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 15px; border-radius: var(--border-radius); font-size: 1.1em; z-index: 5; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; max-width: 80%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .channel-info.visible { opacity: 1; }
        .loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 4px solid var(--tertiary-bg); border-top: 4px solid var(--highlight-color); border-radius: 50%; width: 45px; height: 45px; animation: spin 0.8s linear infinite; z-index: 1; display: none; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }

    </style>
</head>
<body>
    <div class="player-container">
        <div id="sidebar">
             <div class="sidebar-header">
                 <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjtH1eFwNcBk9FvfM8ozeG6zjDtvJR2j2CdfNtfn8rj0JP9PRWR7zeL_ayD_dwmmuqOe8-sTp-TcOGCVsg5yhUNBO_PqRVI9gCMu3B1x2MQ1ZsitAg-1NKxQ70x3H-O9eehSCsQO6DzLPxcB_uZpfGmfziYNcXQ0JylvrGY1PE-sc9nJ76l2c62PG3Kcvs/w457-h136/JORGEDEZ-19-3-2025.png" alt="Logo Jorgedez" class="app-logo" onerror="this.style.display='none'">
                 <span id="channelCount" class="channel-count">0</span>
             </div>
             <div class="channel-list-container">
                 <ul id="channelList" class="channel-list" tabindex="-1"></ul>
             </div>
        </div>

        <div id="playerContent" class="player-content">
            <div id="channelInfo" class="channel-info"></div>
            <div id="loader" class="loader"></div>
            <video id="videoPlayer" controlslist="nodownload nofullscreen noremoteplayback" disablepictureinpicture playsinline></video>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM References ---
            const video = document.getElementById('videoPlayer');
            const sidebar = document.getElementById('sidebar');
            const channelListElement = document.getElementById('channelList');
            const channelInfoElement = document.getElementById('channelInfo');
            const loaderElement = document.getElementById('loader');
            const playerContent = document.getElementById('playerContent');
            const channelCountElement = document.getElementById('channelCount');
            // Reference to the scrollable container
            const channelListContainer = document.querySelector('.channel-list-container');


            // --- M3U URL ---
            const m3uUrl = 'https://raw.githubusercontent.com/sejo48/chanejorgedez/refs/heads/main/listaoficial.m3u';

            // --- State ---
            let channels = [];
            let currentChannelIndex = -1;
            let hls = null;
            let channelInfoTimeout;
            let isSidebarFocused = false;
            let autoHideSidebarTimeoutId = null;

            // --- Favorites ---
            let favoriteChannels = new Set();
            const FAVORITES_STORAGE_KEY = 'm3uPlayer_favorites_v2';

            // --- Last Channel ---
            const LAST_CHANNEL_STORAGE_KEY = 'm3uPlayer_lastChannelIndex';

            // --- Volume Persistence ---
            const VOLUME_STORAGE_KEY = 'm3uPlayer_volume';
            const MUTED_STORAGE_KEY = 'm3uPlayer_muted';

            // --- HLS Initialization ---
            if (Hls.isSupported()) {
                console.log("HLS.js is supported.");
                hls = new Hls({});
                hls.on(Hls.Events.ERROR, (event, data) => {
                    const currentChannelObject = channels.find(ch => ch.index === currentChannelIndex);
                    handleError(currentChannelObject, data);
                });
                hls.attachMedia(video);
            } else {
                console.log("HLS.js is not supported.");
            }

            // --- LocalStorage Functions ---
            function saveToLocalStorage(key, value) {
                try { localStorage.setItem(key, JSON.stringify(value)); }
                catch (e) { console.error(`Error saving LS (${key}):`, e); }
            }
            function loadFromLocalStorage(key, defaultValue = null) {
                try { const sv = localStorage.getItem(key); return sv !== null ? JSON.parse(sv) : defaultValue; }
                catch (e) { console.error(`Error loading LS (${key}):`, e); return defaultValue; }
            }

            // --- Load Initial State ---
            function loadInitialState() {
                const savedFavorites = loadFromLocalStorage(FAVORITES_STORAGE_KEY, []);
                favoriteChannels = new Set(savedFavorites);
                console.log(`Favorites loaded: ${favoriteChannels.size}`);
                const savedIndex = loadFromLocalStorage(LAST_CHANNEL_STORAGE_KEY, -1);
                if (channels.some(ch => ch.index === savedIndex)) {
                    currentChannelIndex = savedIndex;
                    console.log(`Last channel loaded: ${currentChannelIndex}`);
                } else {
                    currentChannelIndex = channels.length > 0 ? channels[0].index : -1;
                    console.log(`Fallback index: ${currentChannelIndex}`);
                }
                const savedVolume = loadFromLocalStorage(VOLUME_STORAGE_KEY, 0.8);
                const savedMuted = loadFromLocalStorage(MUTED_STORAGE_KEY, false);
                video.volume = savedVolume; video.muted = savedMuted;
                console.log(`Volume loaded: ${video.volume}, Muted: ${video.muted}`);
            }

            // --- Fetch and Parse M3U ---
            async function fetchAndParseM3U(url) {
                showLoader(true);
                try {
                    const response = await fetch(`${url}?t=${Date.now()}`);
                    if (!response.ok) throw new Error(`Fetch M3U failed (${response.status})`);
                    const m3uText = await response.text();
                    channels = parseM3U(m3uText);
                    console.log(`Channels parsed: ${channels.length}`);
                    if (channelCountElement) channelCountElement.textContent = channels.length;
                    loadInitialState();
                    renderChannelList();
                    if (channels.length > 0) {
                        // highlightChannel(currentChannelIndex); // highlightChannel is now called within focusChannel
                        const initialChannel = channels.find(ch => ch.index === currentChannelIndex);
                        showChannelInfo(initialChannel?.name || "Select channel");
                        // Initial focus setting
                        requestAnimationFrame(() => focusChannel(currentChannelIndex, true)); // Use true for initial load centering
                    } else {
                        channelListElement.innerHTML = `<li style="padding: 15px;">Empty list.</li>`;
                        showChannelInfo("No channels found");
                    }
                } catch (error) {
                    console.error("M3U Error:", error);
                    channelListElement.innerHTML = `<li style="padding: 15px; color: #ff8a80;">Error: ${error.message}</li>`;
                    showChannelInfo("Error loading channels");
                    if (channelCountElement) channelCountElement.textContent = 'X';
                } finally {
                    showLoader(false);
                }
            }

            // --- Parse M3U ---
            function parseM3U(text) {
                const lines = text.split('\n'); const parsedChannels = [];
                let currentChannel = {}; let channelIndex = 0;
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('#EXTM3U')) continue;
                    if (trimmedLine.startsWith('#EXTINF:')) {
                        currentChannel = { name: 'Unknown', url: '', logo: null, group: '', index: channelIndex };
                        const infoLine = trimmedLine.substring(8); const commaIndex = infoLine.lastIndexOf(',');
                        if (commaIndex === -1) { console.warn("Malformed #EXTINF:", trimmedLine); currentChannel = {}; continue; }
                        const attributesPart = infoLine.substring(0, commaIndex); const namePart = infoLine.substring(commaIndex + 1);
                        currentChannel.name = namePart.trim() || 'Unknown';
                        const logoMatch = attributesPart.match(/tvg-logo="([^"]*)"/); if (logoMatch?.[1]) currentChannel.logo = logoMatch[1];
                        const groupMatch = attributesPart.match(/group-title="([^"]*)"/); if (groupMatch?.[1]) currentChannel.group = groupMatch[1];
                    } else if (trimmedLine && !trimmedLine.startsWith('#')) {
                        if (currentChannel.name) {
                            currentChannel.url = trimmedLine;
                            if (currentChannel.url?.startsWith('http')) { parsedChannels.push(currentChannel); channelIndex++; }
                            else { console.warn(`Skipped channel "${currentChannel.name}" (bad URL): ${currentChannel.url}`); }
                            currentChannel = {};
                        }
                    }
                } return parsedChannels;
            }

             // --- Render Channel List (with Favorites Sorting) ---
            function renderChannelList() {
                channels.sort((a, b) => {
                    const aIsFav = favoriteChannels.has(a.url); const bIsFav = favoriteChannels.has(b.url);
                    if (aIsFav && !bIsFav) return -1; if (!aIsFav && bIsFav) return 1;
                    return a.index - b.index;
                });
                channelListElement.innerHTML = '';
                channels.forEach((channel) => {
                    const index = channel.index; const listItem = document.createElement('li');
                    listItem.className = 'channel-item'; listItem.dataset.index = index; listItem.tabIndex = 0;
                    if (channel.logo) {
                        const logoImg = document.createElement('img'); logoImg.src = channel.logo; logoImg.alt = '';
                        logoImg.className = 'channel-logo'; logoImg.loading = 'lazy';
                        logoImg.onerror = (e) => { e.target.style.display = 'none'; }; listItem.appendChild(logoImg);
                    }
                    const nameSpan = document.createElement('span'); nameSpan.className = 'channel-name';
                    nameSpan.textContent = channel.name || 'Unknown'; listItem.appendChild(nameSpan);
                    const favButton = document.createElement('button'); favButton.className = 'favorite-btn';
                    favButton.setAttribute('aria-label', 'Mark favorite'); favButton.dataset.channelUrl = channel.url;
                    favButton.innerHTML = `<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>`;
                    if (favoriteChannels.has(channel.url)) { favButton.classList.add('is-favorite'); favButton.setAttribute('aria-label', 'Remove favorite'); }
                    favButton.addEventListener('click', (event) => {
                        event.stopPropagation(); toggleFavorite(channel.url, favButton);
                        const currentFocusedIndex = parseInt(listItem.dataset.index, 10);
                        renderChannelList();
                        requestAnimationFrame(() => { focusChannel(currentFocusedIndex); });
                    }); listItem.appendChild(favButton);
                    listItem.addEventListener('click', () => selectAndPlayChannel(index));
                    listItem.addEventListener('focus', () => isSidebarFocused = true);
                    listItem.addEventListener('blur', () => isSidebarFocused = false);
                    channelListElement.appendChild(listItem);
                });
                // Highlight is handled by focusChannel now
                // highlightChannel(currentChannelIndex);
            }

            // --- Favorite Logic ---
            function toggleFavorite(channelUrl, buttonElement) {
                const channelName = channels.find(ch => ch.url === channelUrl)?.name || 'Channel';
                if (favoriteChannels.has(channelUrl)) {
                    favoriteChannels.delete(channelUrl); if(buttonElement) buttonElement.classList.remove('is-favorite');
                    console.log(`Favorite removed: ${channelUrl}`); showChannelInfo(`"${channelName}" removed from Favorites`);
                } else {
                    favoriteChannels.add(channelUrl); if(buttonElement) buttonElement.classList.add('is-favorite');
                    console.log(`Favorite added: ${channelUrl}`); showChannelInfo(`"${channelName}" added to Favorites`);
                }
                saveToLocalStorage(FAVORITES_STORAGE_KEY, Array.from(favoriteChannels));
            }

            // --- Video Playback ---
            function playChannel(index) {
                console.log(`Play index: ${index}`);
                const channel = channels.find(ch => ch.index === index);
                if (!channel) { console.warn(`Channel ${index} not found.`); showChannelInfo("Error: Channel not found"); return; }
                currentChannelIndex = index; saveToLocalStorage(LAST_CHANNEL_STORAGE_KEY, currentChannelIndex);
                showLoader(true); video.style.opacity = 0.5;
                console.log(`Playing [${index}]: ${channel.name} (${channel.url})`); showChannelInfo(channel.name);
                video.pause(); clearAutoHideTimer();
                const videoUrl = channel.url; const isHlsStream = videoUrl.toLowerCase().endsWith('.m3u8');
                try {
                    if (isHlsStream) {
                        if (hls) {
                            console.log("Using HLS.js"); hls.stopLoad(); hls.detachMedia(); hls.loadSource(videoUrl); hls.attachMedia(video);
                            hls.once(Hls.Events.MANIFEST_PARSED, () => video.play().catch(handlePlayError));
                        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                            console.log("Using native HLS"); video.removeAttribute('src'); video.src = ''; video.load(); video.src = videoUrl;
                            video.addEventListener('loadedmetadata', () => video.play().catch(handlePlayError), { once: true });
                            video.addEventListener('error', (e) => handleError(channel, { type: 'Native HLS Error', details: video.error?.message || 'Err' }), { once: true });
                        } else { throw new Error('HLS not supported.'); }
                    } else {
                        console.log("Using direct playback"); if (hls) { hls.stopLoad(); hls.detachMedia(); }
                        video.removeAttribute('src'); video.src = ''; video.load(); video.src = videoUrl;
                        video.play().catch(handlePlayError);
                        video.addEventListener('error', (e) => handleError(channel, { type: 'Direct Error', details: video.error?.message || 'Err' }), { once: true });
                    }
                } catch (error) { console.error("Setup error:", error); handleError(channel, { type: 'Setup Error', details: error.message, fatal: true }); }
                video.removeEventListener('playing', onPlaying); video.addEventListener('playing', onPlaying);
            }
            function onPlaying() { console.log("Playing event."); showLoader(false); video.style.opacity = 1; startAutoHideTimer(); }
            function handlePlayError(e) { console.error("Play error:", e); showLoader(false); video.style.opacity = 1; showChannelInfo(`Play Error: ${e.name}`); clearAutoHideTimer(); }

            // --- Handle General Errors ---
            function handleError(channel, errorData) {
                const channelName = channel ? channel.name : 'unknown'; const channelIndex = channel ? channel.index : -1;
                console.error(`Error channel "${channelName}" [${channelIndex}]:`, errorData);
                showLoader(false); video.style.opacity = 1;
                let errorMsg = `Error: ${channelName}`;
                if (errorData?.type === Hls.ErrorTypes.NETWORK_ERROR) errorMsg += ` (Net: ${errorData.details})`;
                else if (errorData?.type === Hls.ErrorTypes.MEDIA_ERROR) errorMsg += ` (Media: ${errorData.details})`;
                else if (errorData?.details) errorMsg += ` (${errorData.details})`;
                else if (typeof errorData === 'string') errorMsg += ` (${errorData})`;
                if (errorData?.fatal) {
                    errorMsg += " - Stream lost/unavailable."; console.warn("Fatal error. No auto switch.");
                    if (hls && hls.media === video) { hls.stopLoad(); }
                }
                showChannelInfo(errorMsg + " Select another channel."); clearAutoHideTimer();
            }

            // --- Select and Play ---
            function selectAndPlayChannel(index) {
                console.log(`Select & Play: ${index}`);
                const channel = channels.find(ch => ch.index === index);
                if (!channel) { console.warn(`Invalid channel: ${index}`); return; }
                // highlightChannel(index); // Highlight is now part of focusChannel
                focusChannel(index); // Ensure focus and centering before playing
                playChannel(index);
            }

            // --- UI Functions ---
            function showLoader(show) { loaderElement.style.display = show ? 'block' : 'none'; }
            function clearAutoHideTimer() { if (autoHideSidebarTimeoutId) { clearTimeout(autoHideSidebarTimeoutId); autoHideSidebarTimeoutId = null; } }
            function startAutoHideTimer() { clearAutoHideTimer(); autoHideSidebarTimeoutId = setTimeout(() => { if (!sidebar.classList.contains('hidden') && !video.paused) { hideSidebar(); } autoHideSidebarTimeoutId = null; }, 2500); }
            function toggleSidebar() { clearAutoHideTimer(); sidebar.classList.contains('hidden') ? showSidebar() : hideSidebar(); }
            function hideSidebar() { if (!sidebar.classList.contains('hidden')) { sidebar.classList.add('hidden'); console.log("Sidebar hidden"); playerContent.focus(); } }
            function showSidebar() {
                clearAutoHideTimer();
                if (sidebar.classList.contains('hidden')) {
                    sidebar.classList.remove('hidden');
                    console.log("Sidebar shown");
                    // Focus after animation might be slightly delayed, use rAF
                    requestAnimationFrame(() => focusChannel(currentChannelIndex));
                } else {
                    // If already shown, just ensure focus
                    focusChannel(currentChannelIndex);
                }
            }

            /**
             * Highlights a specific channel item in the list. (Called by focusChannel)
             * @param {number} index - The index of the channel to highlight.
             */
            function highlightChannel(index) {
                channelListElement.querySelectorAll('.channel-item').forEach((item) => {
                    const itemIndex = parseInt(item.dataset.index, 10);
                    item.classList.toggle('selected', itemIndex === index);
                });
            }

            /**
             * Sets focus to a specific channel item and centers it vertically.
             * @param {number} index - The index of the channel item to focus.
             * @param {boolean} [instant=false] - Use instant scroll for initial load.
             */
            function focusChannel(index, instant = false) {
                if (sidebar.classList.contains('hidden')) {
                    // If sidebar is hidden, show it first. showSidebar will call focusChannel again.
                    showSidebar();
                    return;
                }
                const itemToFocus = channelListElement.querySelector(`.channel-item[data-index="${index}"]`);
                if (itemToFocus) {
                    // Set focus first
                    itemToFocus.focus({ preventScroll: true }); // Prevent default scroll behavior

                    // Highlight the item visually
                    highlightChannel(index);

                    // --- MODIFICACIÓN: Centrar el elemento enfocado ---
                    // Use scrollIntoView with 'center' block alignment
                    itemToFocus.scrollIntoView({
                        behavior: instant ? 'instant' : 'smooth', // Use 'instant' for initial load
                        block: 'center',
                        inline: 'nearest' // Keep horizontal alignment default
                    });
                    console.log(`Focused and centered channel index: ${index}`);

                } else {
                    console.warn(`Item ${index} not found for focus.`);
                    const firstItem = channelListElement.querySelector('.channel-item');
                    if (firstItem) firstItem.focus(); else channelListElement.focus();
                }
            }

            /**
             * Displays a message in the channel info area.
             * @param {string} text - The message to display.
             */
            function showChannelInfo(text) {
                clearTimeout(channelInfoTimeout); channelInfoElement.textContent = text;
                channelInfoElement.classList.add('visible');
                channelInfoTimeout = setTimeout(() => { channelInfoElement.classList.remove('visible'); }, 4000);
            }

            // --- Video Listeners ---
            video.addEventListener('pause', () => { console.log("Video paused."); clearAutoHideTimer(); });
            video.addEventListener('ended', () => { console.log("Video ended."); clearAutoHideTimer(); const endedChannel = channels.find(ch=>ch.index===currentChannelIndex); showChannelInfo(`"${endedChannel?.name}" finished.`); });
            video.addEventListener('volumechange', () => { console.log(`Volume: ${video.volume}, Muted: ${video.muted}`); saveToLocalStorage(VOLUME_STORAGE_KEY, video.volume); saveToLocalStorage(MUTED_STORAGE_KEY, video.muted); });

            // --- Keyboard/Remote Handling ---
            document.addEventListener('keydown', (event) => {
                if (event.target.tagName === 'INPUT' || ['Shift', 'Control', 'Alt', 'Meta'].includes(event.key)) return;

                if (sidebar.classList.contains('hidden')) {
                    if (event.key !== 'Backspace' && event.key !== 'Escape' && event.key !== 'b' && event.key !== 'B') {
                        event.preventDefault(); showSidebar(); return;
                    } else if (event.key === 'Backspace' || event.key === 'Escape' || event.key === 'b' || event.key === 'B') {
                        event.preventDefault(); return;
                    }
                }

                isSidebarFocused = sidebar.contains(document.activeElement) && document.activeElement.classList.contains('channel-item');

                if (!sidebar.classList.contains('hidden')) {
                    if (isSidebarFocused) {
                        const focusedElement = document.activeElement;
                        const focusedIndex = focusedElement?.classList.contains('channel-item') ? parseInt(focusedElement.dataset.index, 10) : -1;
                        switch (event.key) {
                            case 'ArrowUp': event.preventDefault(); navigateList(-1); break;
                            case 'ArrowDown': event.preventDefault(); navigateList(1); break;
                            case 'Enter': case ' ':
                                event.preventDefault(); if (focusedIndex !== -1) { selectAndPlayChannel(focusedIndex); } break;
                            case 'ArrowRight':
                                event.preventDefault();
                                if (focusedElement?.classList.contains('channel-item')) {
                                     const favButton = focusedElement.querySelector('.favorite-btn'); const channelUrl = favButton?.dataset.channelUrl;
                                     if(favButton && channelUrl && focusedIndex !== -1) {
                                         toggleFavorite(channelUrl, favButton); renderChannelList();
                                         requestAnimationFrame(() => { focusChannel(focusedIndex); });
                                     }
                                } break;
                            case 'Backspace': case 'Escape': case 'b': case 'B':
                                event.preventDefault(); hideSidebar(); break;
                            case 'ArrowLeft': event.preventDefault(); break; // Prevent back navigation
                        }
                    } else { // Focus outside list, sidebar visible
                        switch (event.key) {
                            case 'Backspace': case 'Escape': case 'b': case 'B': event.preventDefault(); hideSidebar(); break;
                            case ' ': event.preventDefault(); if (video.src || hls?.url) { if (video.paused) video.play().catch(handlePlayError); else video.pause(); } break;
                            case 'm': case 'M': event.preventDefault(); video.muted = !video.muted; showChannelInfo(video.muted ? "Muted" : "Unmuted"); break;
                            case 'ArrowUp': event.preventDefault(); adjustVolume(0.1); break;
                            case 'ArrowDown': event.preventDefault(); adjustVolume(-0.1); break;
                            case 'f': case 'F': event.preventDefault(); toggleFullScreen(); break;
                            case 'ArrowLeft': case 'ArrowRight': event.preventDefault(); break; // Ignore horizontal arrows here
                        }
                    }
                }
            });

            // --- List Navigation ---
            /**
             * Navigates up or down, updating focus and centering.
             * @param {number} direction - -1 for up, 1 for down.
             */
            function navigateList(direction) {
                 if (channels.length === 0) return;
                 const items = Array.from(channelListElement.querySelectorAll('.channel-item'));
                 const currentFocusedElement = document.activeElement;
                 let currentVisualIndex = -1;

                 if (currentFocusedElement && currentFocusedElement.classList.contains('channel-item')) {
                     currentVisualIndex = items.indexOf(currentFocusedElement);
                 } else {
                     const logicalIndexInVisual = items.findIndex(item => parseInt(item.dataset.index, 10) === currentChannelIndex);
                     currentVisualIndex = (logicalIndexInVisual !== -1) ? logicalIndexInVisual : 0;
                 }

                 let nextVisualIndex = currentVisualIndex + direction;
                 nextVisualIndex = Math.max(0, Math.min(nextVisualIndex, items.length - 1));

                 if (nextVisualIndex !== currentVisualIndex && items[nextVisualIndex]) {
                     const nextElement = items[nextVisualIndex];
                     const nextLogicalIndex = parseInt(nextElement.dataset.index, 10);
                     currentChannelIndex = nextLogicalIndex; // Update logical index
                     // Focus and center the new item
                     focusChannel(currentChannelIndex);
                 } else if (items[currentVisualIndex]){
                     // If at boundary, ensure the current item is focused and centered
                     focusChannel(parseInt(items[currentVisualIndex].dataset.index, 10));
                 }
            }

            // --- Adjust Volume ---
            function adjustVolume(change) {
                let newVolume = Math.max(0, Math.min(1, video.volume + change)); video.volume = newVolume;
                if (change > 0 && video.muted) video.muted = false;
                console.log("Volume:", Math.round(video.volume * 100) + "%"); showChannelInfo(`Volume: ${Math.round(video.volume * 100)}%`);
            }

            // --- Fullscreen ---
            function toggleFullScreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    if (elem.requestFullscreen) { elem.requestFullscreen().catch(err => { console.error(`FS Error: ${err.message}`); showChannelInfo("Fullscreen unavailable"); }); }
                    else if (elem.webkitRequestFullscreen) { elem.webkitRequestFullscreen(); } /* Safari */
                    else if (elem.msRequestFullscreen) { elem.msRequestFullscreen(); } /* IE11 */
                    else { showChannelInfo("Fullscreen not supported"); } console.log("Entering fullscreen");
                } else {
                    if (document.exitFullscreen) { document.exitFullscreen(); }
                    else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } /* Safari */
                    else if (document.msExitFullscreen) { document.msExitFullscreen(); } /* IE11 */
                    console.log("Exiting fullscreen");
                }
            }

            // --- Initial Load ---
            fetchAndParseM3U(m3uUrl);

            // --- Player Click Listener ---
            playerContent.addEventListener('click', (event) => {
                 if (event.target === playerContent) { toggleSidebar(); }
            });

        });
    </script>
</body>
</html>
