<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reproductor de TV Online (M3U) - TV</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script><!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reproductor Smart TV M3U v8</title> <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        :root {
            --primary-bg: #121212;
            --secondary-bg: #1e1e1e;
            --tertiary-bg: #2a2a2a;
            --text-color: #e0e0e0;
            --text-secondary-color: #b3b3b3;
            --highlight-color: #1DB954;
            --control-icon-color: #ffffff;
            --sidebar-width: 300px;
            --control-bar-height: 65px;
            --border-radius: 4px;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --transition-speed: 0.3s;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; overflow: hidden; background-color: var(--primary-bg); color: var(--text-color); font-family: var(--font-family); }
        .player-container { display: flex; height: 100%; width: 100%; position: relative; overflow: hidden; }

        #sidebar {
            width: var(--sidebar-width);
            min-width: var(--sidebar-width);
            background-color: var(--secondary-bg);
            height: 100%;
            overflow: hidden;
            transition: transform var(--transition-speed) ease-in-out, width var(--transition-speed) ease-in-out, min-width var(--transition-speed) ease-in-out, padding var(--transition-speed) ease-in-out, border var(--transition-speed) ease-in-out; /* Añadir transiciones para suavizar */
            z-index: 10;
            border-right: 1px solid var(--tertiary-bg);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        #sidebar.hidden {
            transform: translateX(-100%);
            width: 0;
            min-width: 0;
            padding-left: 0;
            padding-right: 0;
            border: none;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 10px 15px; /* Ajustar padding */
            border-bottom: 1px solid var(--tertiary-bg);
            transition: padding var(--transition-speed), border var(--transition-speed), height var(--transition-speed), opacity var(--transition-speed);
            display: flex; /* Usar Flexbox */
            align-items: center; /* Centrar verticalmente */
            justify-content: center; /* Centrar horizontalmente */
            gap: 10px; /* Espacio entre logo y contador */
            height: 70px; /* Altura fija para evitar saltos */
            opacity: 1;
        }
        #sidebar.hidden .sidebar-header { padding: 0; border: none; height: 0; opacity: 0; overflow: hidden; }

        .app-logo {
            max-width: 70%; /* Ajustar tamaño */
            max-height: 40px; /* Ajustar altura */
            object-fit: contain;
            display: block; /* Asegurar que sea bloque */
        }

        .channel-count {
            background-color: var(--tertiary-bg);
            color: var(--text-color);
            font-size: 0.75em; /* Tamaño pequeño */
            font-weight: bold;
            border-radius: 50%; /* Círculo */
            width: 28px; /* Tamaño fijo */
            height: 28px;
            display: inline-flex; /* Usar flex para centrar número */
            align-items: center;
            justify-content: center;
            line-height: 1;
            flex-shrink: 0; /* Evitar que se encoja */
            transition: opacity var(--transition-speed);
        }
        #sidebar.hidden .channel-count { opacity: 0; } /* Ocultar contador */


        .channel-list-container { flex-grow: 1; overflow-y: auto; transition: opacity var(--transition-speed); }
         #sidebar.hidden .channel-list-container { opacity: 0; }

        .channel-list-container::-webkit-scrollbar { width: 8px; }
        .channel-list-container::-webkit-scrollbar-track { background: var(--secondary-bg); }
        .channel-list-container::-webkit-scrollbar-thumb { background-color: var(--tertiary-bg); border-radius: 4px; }
        .channel-list-container::-webkit-scrollbar-thumb:hover { background-color: #555; }
        .channel-list { list-style: none; padding: 0; }
        .channel-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--tertiary-bg); transition: background-color 0.15s ease-out; font-size: 0.95em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary-color); }
        .channel-item:last-child { border-bottom: none; }
        .channel-logo { width: 32px; height: 32px; margin-right: 12px; object-fit: contain; flex-shrink: 0; background-color: rgba(255, 255, 255, 0.1); border-radius: var(--border-radius); vertical-align: middle; }
        .channel-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .channel-item:hover, .channel-item:focus { background-color: var(--tertiary-bg); color: var(--text-color); outline: none; }
        .channel-item.selected { background-color: var(--highlight-color); font-weight: bold; color: var(--primary-bg); }
        .channel-item.selected .channel-name { color: var(--primary-bg); }
        .channel-item.selected:hover { background-color: #1aa34a; }

        .player-content { flex-grow: 1; height: 100%; display: flex; flex-direction: column; position: relative; background-color: #000; }
        #videoPlayer { width: 100%; height: 100%; flex-grow: 1; background-color: #000; display: block; object-fit: contain; }
        .controls-bar { height: var(--control-bar-height); background: linear-gradient(to top, rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0)); display: flex; align-items: center; padding: 0 20px; position: absolute; bottom: 0; left: 0; width: 100%; opacity: 0; transition: opacity 0.3s ease-in-out; z-index: 20; pointer-events: none; }
        .player-content:hover .controls-bar, .player-content.controls-visible .controls-bar { opacity: 1; pointer-events: auto; }
        .controls-bar button { background: none; border: none; color: var(--control-icon-color); cursor: pointer; margin: 0 10px; padding: 10px; line-height: 1; transition: transform 0.1s ease-out, color 0.1s ease-out; display: inline-flex; align-items: center; justify-content: center; }
        .controls-bar button svg { width: 24px; height: 24px; stroke: currentColor; stroke-width: 2; fill: none; stroke-linecap: round; stroke-linejoin: round; }
        .controls-bar button:hover { color: var(--highlight-color); transform: scale(1.1); }
        #playPauseButton .icon-pause, #playPauseButton.playing .icon-play { display: none; }
        #playPauseButton.playing .icon-pause { display: inline-block; }
        #muteButton .icon-volume-x, #muteButton:not(.muted) .icon-volume-2 { display: none; }
        #muteButton.muted .icon-volume-x { display: inline-block; }
        #muteButton:not(.muted) .icon-volume-2 { display: inline-block;}
        .volume-control { display: flex; align-items: center; margin-left: 5px; }
        #volumeSlider { cursor: pointer; width: 100px; margin-left: 8px; height: 5px; appearance: none; background: rgba(255, 255, 255, 0.3); border-radius: 3px; outline: none; transition: opacity 0.2s ease; }
        #volumeSlider::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: var(--control-icon-color); border-radius: 50%; cursor: pointer; }
        #volumeSlider::-moz-range-thumb { width: 14px; height: 14px; background: var(--control-icon-color); border-radius: 50%; cursor: pointer; border: none; }
        #volumeSlider:disabled { opacity: 0.5; cursor: not-allowed; }
        .channel-info { position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 15px; border-radius: var(--border-radius); font-size: 1.1em; z-index: 5; opacity: 0; transition: opacity 0.5s ease; pointer-events: none; max-width: 80%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .channel-info.visible { opacity: 1; }
        .loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 6px solid var(--tertiary-bg); border-top: 6px solid var(--highlight-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; z-index: 1; display: none; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
    </style>
</head>
<body>
    <div class="player-container">
        <div id="sidebar">
            <div class="sidebar-header">
                <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjtH1eFwNcBk9FvfM8ozeG6zjDtvJR2j2CdfNtfn8rj0JP9PRWR7zeL_ayD_dwmmuqOe8-sTp-TcOGCVsg5yhUNBO_PqRVI9gCMu3B1x2MQ1ZsitAg-1NKxQ70x3H-O9eehSCsQO6DzLPxcB_uZpfGmfziYNcXQ0JylvrGY1PE-sc9nJ76l2c62PG3Kcvs/w457-h136/JORGEDEZ-19-3-2025.png"
                     alt="Logo Jorgedez" class="app-logo"
                     onerror="this.style.display='none'">
                <span id="channelCount" class="channel-count">0</span>
            </div>
            <div class="channel-list-container">
                <ul id="channelList" class="channel-list" tabindex="-1"></ul>
            </div>
        </div>
        <div id="playerContent" class="player-content">
            <div id="channelInfo" class="channel-info"></div>
            <div id="loader" class="loader"></div>
            <video id="videoPlayer" controlslist="nodownload nofullscreen noremoteplayback" disablepictureinpicture playsinline tabindex="0"></video>
            <div class="controls-bar">
                <button id="playPauseButton" title="Reproducir/Pausar">
                    <svg class="icon-play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    <svg class="icon-pause" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                </button>
                <button id="muteButton" title="Silenciar/Activar Sonido">
                    <svg class="icon-volume-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    <svg class="icon-volume-x" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
                </button>
                <div class="volume-control">
                     <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="1" title="Volumen">
                </div>
                 <button id="castButton" title="Enviar a Chromecast (requiere configuración)">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-8"></path><path d="M2 12a9 9 0 0 1 9 9"></path><path d="M2 17a4 4 0 0 1 4 4"></path><line x1="2" y1="22" x2="2.01" y2="22"></line></svg>
                 </button>
                 <div style="flex-grow: 1;"></div>
                 <button id="closeButton" title="Cerrar">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                 </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Referencias DOM
            const video = document.getElementById('videoPlayer');
            const sidebar = document.getElementById('sidebar');
            const channelListElement = document.getElementById('channelList');
            const channelInfoElement = document.getElementById('channelInfo');
            const loaderElement = document.getElementById('loader');
            const playPauseButton = document.getElementById('playPauseButton');
            const muteButton = document.getElementById('muteButton');
            const volumeSlider = document.getElementById('volumeSlider');
            const castButton = document.getElementById('castButton');
            const closeButton = document.getElementById('closeButton');
            const playerContent = document.getElementById('playerContent');
            const controlsBar = document.querySelector('.controls-bar');
            const channelCountElement = document.getElementById('channelCount'); // Referencia al contador

            const m3uUrl = 'https://raw.githubusercontent.com/sejo48/chanejorgedez/refs/heads/main/listaoficial.m3u';

            // Estado
            let channels = [];
            let currentChannelIndex = -1;
            let hls = null;
            let channelInfoTimeout;
            let controlsTimeout;
            let isSidebarFocused = false;
            let autoHideSidebarTimeoutId = null;

            // --- Inicializar HLS ---
            if (Hls.isSupported()) {
                console.log("HLS.js soportado.");
                hls = new Hls({ /* Config HLS */ });
                hls.on(Hls.Events.ERROR, (event, data) => handleError(channels[currentChannelIndex], data));
                hls.attachMedia(video);
            } else { console.log("HLS.js no soportado."); }

            // --- Carga y Parseo M3U ---
            async function fetchAndParseM3U(url) {
                showLoader(true);
                try {
                    const response = await fetch(`${url}?t=${Date.now()}`);
                    if (!response.ok) throw new Error(`Error M3U (${response.status})`);
                    const m3uText = await response.text();
                    channels = parseM3U(m3uText);

                    // --- Actualizar contador de canales ---
                    if (channelCountElement) {
                        channelCountElement.textContent = channels.length;
                    }
                    // --------------------------------------

                    renderChannelList();
                    if (channels.length > 0) {
                        currentChannelIndex = 0;
                        highlightChannel(currentChannelIndex);
                        showChannelInfo("Selecciona un canal o presiona OK");
                        focusChannel(currentChannelIndex);
                    } else {
                        channelListElement.innerHTML = `<li style="padding: 15px;">Lista vacía o formato incorrecto.</li>`;
                        showChannelInfo("No se encontraron canales");
                    }
                } catch (error) {
                    console.error("Error al cargar M3U:", error);
                    channelListElement.innerHTML = `<li style="padding: 15px; color: #ff8a80;">Error: ${error.message}</li>`;
                    showChannelInfo("Error al cargar canales");
                    if (channelCountElement) channelCountElement.textContent = 'X'; // Indicar error
                } finally {
                    showLoader(false);
                }
            }

            function parseM3U(text) { /* ... (sin cambios) ... */
                const lines = text.split('\n');
                const parsedChannels = [];
                let currentChannel = {};
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('#EXTM3U')) continue;
                    if (trimmedLine.startsWith('#EXTINF:')) {
                        currentChannel = { name: 'Sin Nombre', url: '', logo: null, group: '' };
                        const infoLine = trimmedLine.substring(8);
                        const commaIndex = infoLine.lastIndexOf(',');
                        if (commaIndex === -1) continue;
                        const infoPart = infoLine.substring(0, commaIndex);
                        const namePart = infoLine.substring(commaIndex + 1);
                        currentChannel.name = namePart.trim();
                        const logoMatch = infoPart.match(/tvg-logo="([^"]*)"/);
                        if (logoMatch && logoMatch[1]) currentChannel.logo = logoMatch[1];
                        const groupMatch = infoPart.match(/group-title="([^"]*)"/);
                        if (groupMatch) currentChannel.group = groupMatch[1];
                    } else if (trimmedLine && !trimmedLine.startsWith('#')) {
                        if (currentChannel.name) {
                            currentChannel.url = trimmedLine;
                            if (currentChannel.url && (currentChannel.url.startsWith('http://') || currentChannel.url.startsWith('https://'))) {
                                parsedChannels.push(currentChannel);
                            } else {
                                console.warn(`Canal "${currentChannel.name}" omitido (URL inválida): ${currentChannel.url}`);
                            }
                            currentChannel = {};
                        }
                    }
                }
                console.log(`Canales parseados válidos: ${parsedChannels.length}`);
                return parsedChannels;
            }

            // --- Renderizado Lista Canales ---
            function renderChannelList() { /* ... (sin cambios) ... */
                channelListElement.innerHTML = '';
                channels.forEach((channel, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'channel-item';
                    listItem.dataset.index = index;
                    listItem.tabIndex = 0;
                    if (channel.logo) {
                        const logoImg = document.createElement('img');
                        logoImg.src = channel.logo;
                        logoImg.alt = '';
                        logoImg.className = 'channel-logo';
                        logoImg.loading = 'lazy';
                        logoImg.onerror = (e) => { e.target.style.display = 'none'; };
                        listItem.appendChild(logoImg);
                    }
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'channel-name';
                    nameSpan.textContent = channel.name || 'Canal Desconocido';
                    listItem.appendChild(nameSpan);
                    listItem.addEventListener('click', () => {
                        console.log(`Click en canal ${index}: ${channel.name}`);
                        selectAndPlayChannel(index);
                    });
                    listItem.addEventListener('focus', () => isSidebarFocused = true);
                    listItem.addEventListener('blur', () => isSidebarFocused = false);
                    channelListElement.appendChild(listItem);
                });
            }

            // --- Reproducción de Video ---
            function playChannel(index) { /* ... (sin cambios) ... */
                console.log(`playChannel iniciado para índice: ${index}`);
                if (index < 0 || index >= channels.length) { console.warn(`Índice ${index} fuera de rango.`); return; }
                const channel = channels[index];
                showLoader(true);
                video.style.opacity = 0.5;
                console.log(`Intentando reproducir [${index}]: ${channel.name} (${channel.url})`);
                showChannelInfo(channel.name);
                video.pause();
                clearAutoHideTimer();

                const videoUrl = channel.url;
                const isHlsStream = videoUrl.toLowerCase().endsWith('.m3u8');

                try {
                    if (isHlsStream) {
                        if (hls) {
                            hls.stopLoad(); hls.detachMedia();
                            hls.loadSource(videoUrl); hls.attachMedia(video);
                            hls.once(Hls.Events.MANIFEST_PARSED, () => video.play().catch(handlePlayError));
                        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                            video.removeAttribute('src'); video.src = ''; video.load();
                            video.src = videoUrl;
                            video.addEventListener('loadeddata', () => video.play().catch(handlePlayError), { once: true });
                            video.addEventListener('error', () => handleError(channel, { type: 'Native HLS Error', details: video.error?.message }), { once: true });
                        } else { throw new Error('Navegador no soporta HLS.'); }
                    } else {
                        if (hls) { hls.stopLoad(); hls.detachMedia(); }
                        video.removeAttribute('src'); video.src = ''; video.load();
                        video.src = videoUrl;
                        video.play().catch(handlePlayError);
                        video.addEventListener('error', () => handleError(channel, { type: 'Direct Playback Error', details: video.error?.message }), { once: true });
                    }
                } catch (error) {
                     console.error("Error configurando reproducción:", error);
                     handleError(channel, { type: 'Setup Error', details: error.message });
                }
                 video.removeEventListener('playing', onPlaying);
                 video.addEventListener('playing', onPlaying);
            }

             function onPlaying() { /* ... (sin cambios) ... */
                console.log("AutoHide: Evento 'playing' recibido.");
                showLoader(false);
                video.style.opacity = 1;
                updatePlayPauseButton();
                startAutoHideTimer();
             }

             function handlePlayError(e) { /* ... (sin cambios) ... */
                 console.error("Error en video.play():", e);
                 showLoader(false); video.style.opacity = 1;
                 showChannelInfo(`Error al iniciar: ${e.name}`);
                 updatePlayPauseButton(); clearAutoHideTimer();
             }
             function handleError(channel, errorData) { /* ... (sin cambios) ... */
                 const channelName = channel ? channel.name : 'desconocido';
                 console.error(`Error cargando canal ${channelName}:`, errorData);
                 showLoader(false); video.style.opacity = 1;
                 let errorMsg = `Error: ${channelName}`;
                 if (errorData?.type === Hls.ErrorTypes.NETWORK_ERROR) { errorMsg += ` (Error red ${errorData.details})`; }
                 else if (errorData?.type === Hls.ErrorTypes.MEDIA_ERROR) { errorMsg += ` (Error medio ${errorData.details})`; }
                 else if (errorData?.details) { errorMsg += ` (${errorData.details})`; }
                 showChannelInfo(errorMsg); updatePlayPauseButton(); clearAutoHideTimer();
                 if (hls && errorData?.fatal) {
                     console.warn(`Error HLS fatal: ${errorData.type}`);
                     switch(errorData.type) {
                         case Hls.ErrorTypes.NETWORK_ERROR: console.log("Recuperando Network Error..."); hls.startLoad(); break;
                         case Hls.ErrorTypes.MEDIA_ERROR: console.log("Recuperando Media Error..."); hls.recoverMediaError(); break;
                         default: console.log("Error HLS no recuperable."); break;
                     }
                 }
             }
            function selectAndPlayChannel(index) { /* ... (sin cambios) ... */
                 console.log(`selectAndPlayChannel llamado para índice: ${index}`);
                 currentChannelIndex = index;
                 highlightChannel(index);
                 playChannel(index);
             }

            // --- Interfaz de Usuario ---
            function showLoader(show) { loaderElement.style.display = show ? 'block' : 'none'; }

            function clearAutoHideTimer() { /* ... (sin cambios) ... */
                if (autoHideSidebarTimeoutId) {
                    clearTimeout(autoHideSidebarTimeoutId);
                    autoHideSidebarTimeoutId = null;
                    console.log("AutoHide: Timer cancelado.");
                }
            }

            function startAutoHideTimer() { /* ... (sin cambios) ... */
                clearAutoHideTimer();
                console.log("AutoHide: Timer set (4000ms).");
                autoHideSidebarTimeoutId = setTimeout(() => {
                    console.log("AutoHide: Timeout fired.");
                    if (!sidebar.classList.contains('hidden')) {
                        console.log("AutoHide: Condition met (visible). Hiding sidebar.");
                        hideSidebar();
                    } else {
                         console.log("AutoHide: Condition not met (already hidden). Doing nothing.");
                    }
                    autoHideSidebarTimeoutId = null;
                }, 4000);
            }

            function toggleSidebar() { /* ... (sin cambios) ... */
                clearAutoHideTimer();
                sidebar.classList.contains('hidden') ? showSidebar() : hideSidebar();
            }
            function hideSidebar() { /* ... (sin cambios) ... */
                if (!sidebar.classList.contains('hidden')) {
                    sidebar.classList.add('hidden');
                    video.focus();
                    console.log("Sidebar oculta, foco en video");
                }
            }
            function showSidebar() { /* ... (sin cambios) ... */
                clearAutoHideTimer();
                if (sidebar.classList.contains('hidden')) {
                    sidebar.classList.remove('hidden');
                    focusChannel(currentChannelIndex);
                    console.log("Sidebar mostrada, foco en canal:", currentChannelIndex);
                } else {
                    focusChannel(currentChannelIndex);
                }
            }
            function highlightChannel(index) { /* ... (sin cambios) ... */
                channelListElement.querySelectorAll('.channel-item').forEach((item, i) => {
                    item.classList.toggle('selected', i === index);
                    if (i === index) item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                });
            }
            function focusChannel(index) { /* ... (sin cambios) ... */
                const items = channelListElement.querySelectorAll('.channel-item');
                const itemToFocus = items[index] ?? items[0];
                if (itemToFocus) {
                    itemToFocus.focus();
                    highlightChannel(index >= 0 ? index : 0);
                }
            }
            function showChannelInfo(text) { /* ... (sin cambios) ... */
                clearTimeout(channelInfoTimeout);
                channelInfoElement.textContent = text;
                channelInfoElement.classList.add('visible');
                channelInfoTimeout = setTimeout(() => { channelInfoElement.classList.remove('visible'); }, 4500);
            }

             // --- Controles de Video ---
             playPauseButton.addEventListener('click', togglePlayPause);
             muteButton.addEventListener('click', toggleMute);
             volumeSlider.addEventListener('input', handleVolumeChange);
             closeButton.addEventListener('click', () => { if (confirm("¿Cerrar reproductor?")) { window.history.back(); } });
             video.addEventListener('pause', () => { updatePlayPauseButton(); clearAutoHideTimer(); });
             video.addEventListener('ended', () => { updatePlayPauseButton(); clearAutoHideTimer(); });

             function togglePlayPause() { /* ... (sin cambios) ... */
                 console.log("togglePlayPause. Paused:", video.paused);
                 if (!video.src && !hls?.url && channels.length > 0) { console.log("Nada cargado, play canal actual:", currentChannelIndex); selectAndPlayChannel(currentChannelIndex); }
                 else if (video.paused) { console.log("Video pausado, play..."); video.play().catch(handlePlayError); }
                 else { console.log("Video reproduciendo, pause..."); video.pause(); }
             }
             function updatePlayPauseButton() { /* ... (sin cambios) ... */
                 const isPlaying = !video.paused;
                 playPauseButton.classList.toggle('playing', isPlaying);
             }
             function toggleMute() { /* ... (sin cambios) ... */
                 video.muted = !video.muted;
                 muteButton.classList.toggle('muted', video.muted);
                 volumeSlider.disabled = video.muted;
             }
             function handleVolumeChange() { /* ... (sin cambios) ... */
                 video.volume = volumeSlider.value;
                 if (video.volume > 0 && video.muted) { video.muted = false; muteButton.classList.remove('muted'); volumeSlider.disabled = false; }
                 else if (video.volume === 0 && !video.muted) { video.muted = true; muteButton.classList.add('muted'); volumeSlider.disabled = true; }
             }
             volumeSlider.value = video.volume; muteButton.classList.toggle('muted', video.muted); volumeSlider.disabled = video.muted; updatePlayPauseButton();

             // --- Chromecast Placeholder ---
             castButton.addEventListener('click', () => alert('Funcionalidad Chromecast no implementada.'));

            // --- Manejo de Teclado / Control Remoto ---
            document.addEventListener('keydown', (event) => { /* ... (sin cambios) ... */
                 if (['Shift', 'Control', 'Alt', 'Meta'].includes(event.key)) return;
                 if (event.target.tagName === 'INPUT') return;

                 if (sidebar.classList.contains('hidden')) {
                     if (event.key !== 'Backspace' && event.key !== 'Escape' && event.key !== 'b' && event.key !== 'B') {
                         console.log("Keydown: Sidebar oculta, mostrando...");
                         event.preventDefault(); showSidebar(); return;
                     }
                 }
                 if (event.key === 'Backspace' || event.key === 'Escape' || event.key === 'b' || event.key === 'B') {
                     console.log("Keydown: Toggle sidebar...");
                     event.preventDefault(); toggleSidebar(); return;
                 }
                 isSidebarFocused = sidebar.contains(document.activeElement);
                 if (!sidebar.classList.contains('hidden') && isSidebarFocused) {
                     switch (event.key) {
                         case 'ArrowUp': event.preventDefault(); navigateList(-1); break;
                         case 'ArrowDown': event.preventDefault(); navigateList(1); break;
                         case 'Enter': case ' ':
                             event.preventDefault();
                             const focused = document.activeElement;
                             if (focused?.classList.contains('channel-item')) { selectAndPlayChannel(parseInt(focused.dataset.index, 10)); }
                             break;
                         default: break;
                     }
                 }
                 else if (sidebar.classList.contains('hidden') || !isSidebarFocused) {
                     switch(event.key) {
                         case ' ': event.preventDefault(); togglePlayPause(); break;
                         case 'm': case 'M': event.preventDefault(); toggleMute(); break;
                         case 'ArrowLeft': event.preventDefault(); /* Seek? */ break;
                         case 'ArrowRight': event.preventDefault(); /* Seek? */ break;
                         case 'ArrowUp': event.preventDefault(); adjustVolume(0.1); break;
                         case 'ArrowDown': event.preventDefault(); adjustVolume(-0.1); break;
                         case 'f': case 'F': event.preventDefault(); toggleFullScreen(); break;
                         default: break;
                     }
                 }
            });

            function navigateList(direction) { /* ... (sin cambios) ... */
                 let newIndex = Math.max(0, Math.min(currentChannelIndex + direction, channels.length - 1));
                 if (newIndex !== currentChannelIndex) { currentChannelIndex = newIndex; focusChannel(currentChannelIndex); }
             }
            function adjustVolume(delta) { /* ... (sin cambios) ... */
                 let newVolume = Math.max(0, Math.min(1, video.volume + delta));
                 video.volume = newVolume; volumeSlider.value = newVolume;
                 handleVolumeChange(); showControlsTemporarily();
             }
            function toggleFullScreen() { /* ... (sin cambios) ... */
                 if (!document.fullscreenElement) { playerContent.requestFullscreen().catch(err => console.error(`Fullscreen error: ${err.message}`)); }
                 else { document.exitFullscreen(); }
             }

            // --- Visibilidad de Controles ---
             function showControlsTemporarily() { /* ... (sin cambios) ... */
                 playerContent.classList.add('controls-visible');
                 clearTimeout(controlsTimeout);
                 controlsTimeout = setTimeout(() => {
                    if (!video.paused && !playerContent.contains(document.activeElement)) {
                         playerContent.classList.remove('controls-visible');
                    }
                 }, 3500);
             }
             playerContent.addEventListener('mousemove', showControlsTemporarily);
             playerContent.addEventListener('touchstart', showControlsTemporarily);
             playerContent.addEventListener('focusin', showControlsTemporarily);
             video.addEventListener('play', showControlsTemporarily);
             video.addEventListener('pause', () => { clearTimeout(controlsTimeout); playerContent.classList.add('controls-visible'); });

            // --- Inicialización ---
            fetchAndParseM3U(m3uUrl);

        }); // Fin DOMContentLoaded
    </script>
</body>
</html>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Modern Dark Theme --- */
        :root {
            /* Color Palette */
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --surface-hover-color: #2a2a2a;
            --primary-accent: #4A90E2; /* Blue accent */
            --primary-accent-hover: #357ABD;
            --text-primary: #E0E0E0;
            --text-secondary: #A0A0A0;
            --text-on-accent: #FFFFFF;
            --border-color: #383838;
            --favorite-color: #FFD700; /* Gold for favorite */
            --error-color: #CF6679; /* Red for offline/error */
            --success-color: #2ECC71; /* Green for online */
            --unknown-color: #616161; /* Grey for unknown status */
            --loading-color: var(--primary-accent); /* Color para indicador de carga */
            --focus-outline-color: var(--primary-accent); /* Color for focus outline */

            /* Sizing & Radius */
            --border-radius: 8px;
            --spacing-xs: 4px;
            --spacing-s: 8px;
            --spacing-m: 16px;
            --spacing-l: 24px;
            --header-height: 70px;
            --header-height-mobile: 60px;
        }

        /* Global Box Sizing & Overflow Control */
        * {
            box-sizing: border-box;
        }

        html, body {
            overflow-x: hidden; /* Prevent horizontal scroll */
            background-color: var(--bg-color); /* Ensure bg color covers everything */
        }

        /* General Body Styles */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text-primary);
            line-height: 1.6;
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Header Styles */
        .header {
            background-color: var(--surface-color);
            padding: 0 var(--spacing-m);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            height: var(--header-height);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .header img {
            height: 45px; /* Logo height */
            object-fit: contain;
            flex-shrink: 0; /* Prevent logo from shrinking */
        }

        /* Current Channel Title in Header */
        #current-channel-title {
            color: var(--text-primary);
            font-size: 1.1em;
            font-weight: 600;
            margin-left: var(--spacing-l); /* Space between logo and title */
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis for long titles */
            flex-grow: 1; /* Allow title to take available space */
            min-width: 0; /* Important for flex-grow + overflow */
        }


        /* Main Container Layout */
        .container {
            display: flex;
            flex-direction: row; /* Player on left, playlist on right */
            max-width: 1600px; /* Max width for large screens */
            margin: calc(var(--header-height) + var(--spacing-m)) auto var(--spacing-m); /* Top margin for fixed header */
            padding: var(--spacing-m);
            height: calc(100vh - var(--header-height) - (2 * var(--spacing-m))); /* Full height minus header and margins */
            overflow: hidden; /* Prevent container scroll, allow internal scroll */
            gap: var(--spacing-l); /* Gap between player and playlist */
        }

        /* Video Player Container */
        #player-container {
            flex: 3; /* Takes up more space */
            position: relative;
            border-radius: var(--border-radius);
            overflow: hidden;
            background-color: #000; /* Black background for video area */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
             /* Add outline for focus */
            outline: 3px solid transparent;
            outline-offset: 2px;
            transition: outline-color 0.2s ease;
        }
        #player-container:focus, /* Direct focus */
        #player-container:focus-within /* Focus on child (video controls) */
         {
            outline-color: var(--focus-outline-color);
        }


        /* Video Element Styling */
        #my-video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Fit video within container without cropping */
            display: block;
            border-radius: var(--border-radius); /* Match container radius */
        }
        /* Hide default outline on video element itself when controls are focused */
        #my-video:focus {
            outline: none;
        }


        /* Playlist Container */
        #playlist-container {
            flex: 1; /* Takes less space */
            background-color: var(--surface-color);
            border-radius: var(--border-radius);
            padding: var(--spacing-m);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            min-width: 320px; /* Minimum width for playlist */
            max-height: 100%; /* Ensure it doesn't overflow container */
            position: relative; /* For loading indicator */
             /* Add outline for focus */
            outline: 3px solid transparent;
            outline-offset: 2px;
            transition: outline-color 0.2s ease;
        }
         #playlist-container:focus, /* Direct focus */
         #playlist-container:focus-within /* Focus on child (search, list items) */
         {
             outline-color: var(--focus-outline-color);
         }


         /* Container for Title and Count */
        .playlist-title-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-m);
            padding-bottom: var(--spacing-s);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; /* Prevent shrinking */
        }

        #playlist-container h2 {
            margin: 0;
            font-size: 1.25em;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Channel Count Display */
        #channel-count-container {
            width: auto; /* Fit content */
            height: 28px;
            background-color: var(--primary-accent);
            border-radius: 14px; /* Pill shape */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 var(--spacing-s);
            flex-shrink: 0; /* Prevent shrinking */
            margin: 0; /* Reset margin */
        }

        #channel-count-number {
            color: var(--text-on-accent);
            font-size: 0.8em;
            font-weight: 600;
            line-height: 1; /* Ensure text is centered vertically */
        }

        /* Search Input Styling */
        #search {
            width: 100%;
            padding: var(--spacing-s) var(--spacing-m);
            margin-bottom: var(--spacing-m);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            background-color: var(--bg-color); /* Slightly darker than surface for contrast */
            color: var(--text-primary);
            font-size: 0.95em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
             flex-shrink: 0; /* Prevent shrinking */
        }

        #search::placeholder {
            color: var(--text-secondary);
        }

        #search:focus {
            outline: none;
            border-color: var(--primary-accent);
            box-shadow: 0 0 0 3px var(--focus-outline-color); /* Thicker focus ring for TV */
        }

        /* Playlist (UL) Styling */
        #playlist {
            list-style-type: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; /* Allow list to take remaining space */
            overflow-y: auto; /* Enable vertical scrolling */
            /* Custom Scrollbar */
            &::-webkit-scrollbar { width: 8px; }
            &::-webkit-scrollbar-track { background: var(--surface-color); border-radius: 4px; }
            &::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; border: 2px solid var(--surface-color); }
            &::-webkit-scrollbar-thumb:hover { background-color: var(--text-secondary); }
        }

        /* Playlist Item (LI) Styling */
        #playlist li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: default; /* Default cursor, button inside handles click */
            padding: var(--spacing-s);
            margin-bottom: var(--spacing-s);
            background-color: transparent; /* Use hover effect */
            border-radius: var(--border-radius);
            transition: background-color 0.15s ease-in-out;
            border: 1px solid transparent; /* Placeholder for active border */
            /* Add outline for focus within the list item */
            outline: none; /* Remove default outline */
             position: relative; /* Needed for focus pseudo-elements */
        }

        /* Style for when LI contains the focused element */
        #playlist li:focus-within {
             /* Using box-shadow for focus on LI to avoid layout shifts with outline */
             box-shadow: 0 0 0 3px var(--focus-outline-color) inset;
             background-color: var(--surface-hover-color); /* Highlight background on focus */
        }


        /* Active Channel Styling */
        #playlist li.active {
            background-color: rgba(74, 144, 226, 0.15); /* Light blue highlight */
            border: 1px solid var(--primary-accent);
        }
         /* Combine active and focus-within styles */
        #playlist li.active:focus-within {
            box-shadow: 0 0 0 3px var(--favorite-color) inset; /* Different color for active focus */
        }

        #playlist li.active .channel-title {
             color: var(--primary-accent); /* Highlight title text */
             font-weight: 600;
        }
        #playlist li.active .channel-desc {
             color: var(--text-secondary); /* Keep description subtle */
        }


        /* Channel Button (inside LI) */
         .channel-button {
             background: none;
             border: none;
             padding: 0;
             margin: 0;
             color: inherit;
             font-family: inherit;
             font-size: inherit;
             text-align: left;
             cursor: pointer;
             display: block; /* Make it take full width */
             flex-grow: 1; /* Take available space */
             margin-right: var(--spacing-s); /* Space before star */
             border-radius: var(--border-radius); /* For focus outline */
             overflow: hidden; /* Clip content */
             outline: none; /* Remove default button outline, handled by parent LI */
        }

        /* Channel Info Layout (inside button) */
        .channel-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-s);
            overflow: hidden; /* Prevent content overflow */
        }

        /* Status Dot */
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--unknown-color); /* Default: Unknown */
            margin-right: var(--spacing-s); /* Space between dot and logo */
            flex-shrink: 0; /* Prevent shrinking */
            transition: background-color 0.3s ease;
        }
        .status-dot.online {
            background-color: var(--success-color); /* Green */
        }
        .status-dot.offline {
            background-color: var(--error-color); /* Red */
        }


        /* Channel Logo */
        .channel-info img {
            width: 32px;
            height: 32px;
            border-radius: 50%; /* Circular logos */
            flex-shrink: 0;
            object-fit: cover; /* Cover the area */
            border: 1px solid var(--border-color); /* Subtle border */
            background-color: var(--border-color); /* Placeholder bg */
        }

        /* Channel Text Details */
        .channel-details {
            overflow: hidden; /* Prevent text overflow */
            display: flex;
            flex-direction: column;
        }

        .channel-title {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--text-primary);
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
             transition: color 0.15s ease-in-out;
        }

        .channel-desc {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin: 2px 0 0 0; /* Small top margin */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
             transition: color 0.15s ease-in-out;
        }

        /* Focus state handled by li:focus-within */
        .channel-button:focus {
             outline: none;
        }


        /* Favorite Star Icon */
        .star {
            cursor: pointer;
            color: var(--text-secondary); /* Default grey */
            transition: color 0.2s ease, transform 0.2s ease;
            font-size: 1em;
            flex-shrink: 0;
            padding: var(--spacing-xs); /* Clickable area */
            line-height: 1; /* Align icon */
            margin-right: var(--spacing-xs); /* Space before the edge */
            outline: none; /* Remove default outline */
             border-radius: 50%; /* Make focus ring circular */
        }
         /* Focus state for star handled by parent li:focus-within, but add specific style if needed */
         .star:focus {
             /* Example: Specific visual cue if star itself is focused */
             /* box-shadow: 0 0 0 2px var(--favorite-color); */
         }


        .star:hover {
            transform: scale(1.15); /* Slight grow effect */
            color: var(--text-primary); /* Lighter grey on hover */
        }

        .star.favorite {
            color: var(--favorite-color); /* Gold when favorited */
        }

        .star.favorite:hover {
            filter: brightness(1.1); /* Slightly brighter gold on hover */
        }

        /* Error Overlay Styles */
        .error-overlay {
            position: fixed; /* Cover the whole screen */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9); /* Dark semi-transparent background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Above everything else */
            color: var(--text-primary);
            text-align: center;
            padding: var(--spacing-l);
            display: none; /* Hidden by default */
        }

        .error-message {
            font-size: 1.2em;
            margin-bottom: var(--spacing-l);
            color: var(--error-color); /* Use error color for message */
        }

        .error-buttons {
            display: flex;
            gap: var(--spacing-m);
        }

        .error-button {
            padding: var(--spacing-s) var(--spacing-l);
            background-color: var(--primary-accent);
            border: none;
            border-radius: var(--border-radius);
            color: var(--text-on-accent);
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 0.95em;
            font-weight: 600;
            outline: none; /* Base outline */
        }

        .error-button:hover {
            background-color: var(--primary-accent-hover);
        }
        /* Focus style for error buttons */
        .error-button:focus-visible {
             box-shadow: 0 0 0 3px var(--focus-outline-color); /* Use variable */
             outline: none; /* Ensure no double outline */
        }

        /* Loading Indicator */
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1em;
            color: var(--text-secondary);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-s);
            z-index: 5; /* Ensure it's above playlist items but below header */
        }
        .loading-indicator.show {
            display: flex;
        }
        .spinner {
            border: 4px solid var(--surface-hover-color); /* Light grey */
            border-top: 4px solid var(--loading-color); /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        /* Responsive Design for Mobile (Less relevant for TV, but kept) */
        @media (max-width: 768px) {
             /* Styles remain largely the same, TV focus is primary */
             .header {
                 height: var(--header-height-mobile);
                 padding: 0 var(--spacing-m);
             }
             .header img {
                 height: 35px; /* Smaller logo */
             }

             .container {
                 margin: var(--header-height-mobile) 0 0 0;
                 min-height: calc(100vh - var(--header-height-mobile));
                 flex-direction: column;
                 height: auto;
                 padding: 0;
                 overflow: visible;
                 gap: 0;
             }

             #player-container {
                 flex: none;
                 height: 40vh;
                 width: 100%;
                 margin: 0;
                 border-radius: 0;
                 border-left: none;
                 border-right: none;
                 border-top: none;
                 outline: none; /* Remove outline on mobile */
             }
              #player-container:focus, #player-container:focus-within { outline: none; }

             #my-video {
                 border-radius: 0;
             }

             #playlist-container {
                 flex-grow: 1;
                 width: 100%;
                 border-radius: 0;
                 padding: var(--spacing-m);
                 border: none;
                 min-height: calc(60vh - var(--header-height-mobile));
                 max-height: none;
                 overflow-y: auto;
                 min-width: unset;
                  outline: none; /* Remove outline on mobile */
             }
              #playlist-container:focus, #playlist-container:focus-within { outline: none; }


             .playlist-title-container {
                 padding-bottom: var(--spacing-s);
                 margin-bottom: var(--spacing-m);
             }
             #playlist-container h2 {
                 font-size: 1.1em;
             }
             #channel-count-container {
                 height: 24px;
                 padding: 0 6px;
                 border-radius: 12px;
             }
             #channel-count-number {
                 font-size: 0.75em;
             }

             #search {
                 padding: 10px;
                 font-size: 1em;
             }
              #search:focus {
                  box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.3); /* Revert to subtle focus */
              }

             #playlist li {
                 padding: 10px;
                 margin-bottom: 6px;
             }
              #playlist li:focus-within {
                  box-shadow: none; /* Remove inset shadow */
                  background-color: var(--surface-hover-color); /* Keep hover effect */
              }

             .status-dot {
                 width: 7px;
                 height: 7px;
                 margin-right: 6px;
             }
             .channel-info img {
                 width: 30px;
                 height: 30px;
             }
             .channel-title {
                 font-size: 0.9em;
             }
             .channel-desc {
                 font-size: 0.75em;
             }
             .star {
                 font-size: 1em;
                 margin-right: var(--spacing-xs);
             }
        }
    </style>
</head>
<body>
    <header class="header">
        <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgVIFxWI-sdOR2bVfpbgCotXquColWskv4u4I9HXZhYdsRewDVRNcJ7iLvtKO2xYucvqOv0DKY2MArMnHGF8IvZBI7NYjg0dkjHUN0N8VXwZ73vKjYOajWC6JTze5n1Hcj19V2COVFkN-TtJA7uR_ALIYyIcvUBOwQN1EmURskiBCI_lJK3hFphdSBuCaQ/s320/logo%20(%20JORGEDEZ%20)%20ROJO%20Y%20BLANCO%20PARA%20VIDEO.jpeg" alt="JORGEDEZ Logo">
        <span id="current-channel-title">Cargando canales...</span>
    </header>

    <div class="container">
        <div id="player-container" tabindex="-1" aria-label="Área del reproductor de video">
            <video id="my-video" controls playsinline webkit-playsinline crossorigin="anonymous">
                Tu navegador no soporta el elemento de video.
            </video>
        </div>

        <div id="playlist-container" tabindex="-1" aria-label="Área de la lista de canales">
             <div class="loading-indicator" id="loading-indicator">
                 <div class="spinner"></div>
                 <span>Cargando canales...</span>
             </div>
            <div class="playlist-title-container">
                <h2>Canales</h2>
                <div id="channel-count-container" aria-live="polite" aria-atomic="true">
                    <span id="channel-count-number">0</span>
                </div>
            </div>
            <input type="text" id="search" placeholder="Buscar canal..." aria-label="Buscar canal" disabled>
            <ul id="playlist" aria-label="Lista de canales" role="listbox">
                </ul>
        </div>
    </div>

    <div class="error-overlay" id="error-overlay" role="alertdialog" aria-labelledby="error-message" aria-modal="true">
        <div class="error-message" id="error-message">No se pudo cargar el canal. Intente con otro.</div>
        <div class="error-buttons">
            <button class="error-button" id="try-again-button">Intentar nuevamente</button>
            <button class="error-button" id="try-another-button">Probar otro canal</button>
            <button class="error-button" id="reload-list-button">Recargar Lista M3U</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Configuration ---
            const m3uUrl = 'https://raw.githubusercontent.com/sejo48/chanejorgedez/refs/heads/main/listaoficial.m3u'; // <-- URL DE TU LISTA M3U
            const STATUS_STORAGE_KEY = 'channelStatusesTvPlayer';
            const FAVORITES_STORAGE_KEY = 'favoritesTvChannels';
            const LAST_PLAYED_STORAGE_KEY = 'lastPlayedTvChannel';

            // --- Global State ---
            let channels = [];
            let channelStatuses = JSON.parse(localStorage.getItem(STATUS_STORAGE_KEY)) || {};
            let favorites = JSON.parse(localStorage.getItem(FAVORITES_STORAGE_KEY)) || [];
            let lastAttemptedChannel = null;
            let hls = null;
            let currentChannelIndex = null;
            let videoPlayingListener = null;
            let currentFocus = 'playlist'; // 'playlist' or 'player' - Start focus in playlist

            // --- DOM Elements ---
            const videoPlayer = document.getElementById('my-video');
            const playlist = document.getElementById('playlist');
            const searchInput = document.getElementById('search');
            const playerContainer = document.getElementById('player-container');
            const playlistContainer = document.getElementById('playlist-container');
            const errorOverlay = document.getElementById('error-overlay');
            const errorMessage = document.getElementById('error-message');
            const tryAgainButton = document.getElementById('try-again-button');
            const tryAnotherButton = document.getElementById('try-another-button');
            const reloadListButton = document.getElementById('reload-list-button');
            const currentChannelTitleElement = document.getElementById('current-channel-title');
            const countContainer = document.getElementById('channel-count-container');
            const countSpan = document.getElementById('channel-count-number');
            const loadingIndicator = document.getElementById('loading-indicator');

            // --- Loading Indicator ---
            function showLoading(message = "Cargando canales...") { /* ... (no changes) ... */
                if (loadingIndicator) {
                    loadingIndicator.querySelector('span').textContent = message;
                    loadingIndicator.classList.add('show');
                }
                searchInput.disabled = true;
                playlist.innerHTML = '';
                if (countSpan) countSpan.textContent = '...';
                if (currentChannelTitleElement) currentChannelTitleElement.textContent = 'Cargando...';
            }
            function hideLoading() { /* ... (no changes) ... */
                 if (loadingIndicator) {
                    loadingIndicator.classList.remove('show');
                }
                // Enable search only if channels were loaded
                searchInput.disabled = channels.length === 0;
            }

            // --- M3U Parsing ---
            async function fetchAndParseM3U(url) { /* ... (no changes needed in parsing logic) ... */
                showLoading();
                console.log(`Fetching M3U from: ${url}`);
                try {
                    const response = await fetch(url, { cache: "no-store" });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const m3uText = await response.text();
                    console.log("M3U content fetched successfully.");

                    const lines = m3uText.split(/[\r\n]+/);
                    const parsedChannels = [];
                    let currentChannelInfo = null;

                    const extinfRegex = /#EXTINF:(-?\d+)(.*)/;
                    const attributeRegex = /(\S+?)=(?:"([^"]*)"|([^ ]*))/g;
                    const titleCommaRegex = /,(?!")(.*)/;

                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (!trimmedLine) continue;

                        if (trimmedLine.startsWith('#EXTINF:')) {
                            const match = trimmedLine.match(extinfRegex);
                            if (match) {
                                currentChannelInfo = {
                                    duration: match[1], attributes: {}, title: '', logo: '', descripcion: '', url: ''
                                };
                                const restOfLine = match[2] || '';
                                let attrMatch;
                                while ((attrMatch = attributeRegex.exec(restOfLine)) !== null) {
                                    const key = attrMatch[1].toLowerCase();
                                    const value = attrMatch[2] !== undefined ? attrMatch[2] : attrMatch[3];
                                    currentChannelInfo.attributes[key] = value;
                                }
                                if (currentChannelInfo.attributes['tvg-name']) {
                                    currentChannelInfo.title = currentChannelInfo.attributes['tvg-name'].trim();
                                }
                                if (!currentChannelInfo.title) {
                                    const titleMatch = restOfLine.match(titleCommaRegex);
                                    if (titleMatch && titleMatch[1]) {
                                        currentChannelInfo.title = titleMatch[1].trim();
                                    }
                                }
                                if (!currentChannelInfo.title) { currentChannelInfo.title = 'Sin Título'; }
                                currentChannelInfo.logo = currentChannelInfo.attributes['tvg-logo'] || '';
                                currentChannelInfo.descripcion = currentChannelInfo.attributes['group-title'] || `Canal: ${currentChannelInfo.title}`;
                            } else {
                                console.warn("Unrecognized #EXTINF line:", trimmedLine);
                                currentChannelInfo = null;
                            }
                        } else if (currentChannelInfo && trimmedLine && !trimmedLine.startsWith('#')) {
                            currentChannelInfo.url = trimmedLine;
                            if (currentChannelInfo.url) {
                                parsedChannels.push(currentChannelInfo);
                            } else {
                                console.warn("Skipping channel entry with missing URL:", currentChannelInfo.title);
                            }
                            currentChannelInfo = null;
                        }
                    }

                    console.log(`Parsed ${parsedChannels.length} channels.`);
                    if (parsedChannels.length === 0 && lines.length > 1) {
                         showM3UError("No se encontraron canales válidos en el archivo M3U.");
                         return [];
                    }
                    return parsedChannels;
                } catch (error) {
                    console.error('Error fetching or parsing M3U:', error);
                    showM3UError(`Error al cargar la lista M3U: ${error.message}. Verifica la URL e inténtalo de nuevo.`);
                    return [];
                } finally {
                    hideLoading();
                }
            }

            // --- Error Handling ---
            function showM3UError(message) { /* ... (no changes) ... */
                 errorMessage.textContent = message;
                 errorOverlay.style.display = 'flex';
                 tryAgainButton.style.display = 'none';
                 tryAnotherButton.style.display = 'none';
                 reloadListButton.style.display = 'inline-block';
                 if (countSpan) countSpan.textContent = '0';
                 if (currentChannelTitleElement) currentChannelTitleElement.textContent = 'Error de Lista';
                 searchInput.disabled = true;
                 // Ensure focus is managed when error shows
                 reloadListButton.focus(); // Focus the reload button
                 currentFocus = 'error'; // Special focus state
            }
            function showError(message, channelIndex) { /* ... (minor change to focus) ... */
                console.error("Playback Error Triggered:", message, "Channel Index:", channelIndex);
                lastAttemptedChannel = channelIndex;
                errorMessage.textContent = message;
                errorOverlay.style.display = 'flex';
                tryAgainButton.style.display = 'inline-block';
                tryAnotherButton.style.display = 'inline-block';
                reloadListButton.style.display = 'none';

                if (hls) { hls.stopLoad(); hls.destroy(); hls = null; }
                videoPlayer.pause();
                videoPlayer.removeAttribute('src');
                videoPlayer.load();

                if (currentChannelTitleElement) {
                    currentChannelTitleElement.textContent = 'Error al cargar canal';
                }
                if (channelIndex !== null && channelIndex >= 0 && channelIndex < channels.length) {
                    updateChannelStatus(channelIndex, 'offline');
                }
                 // Focus the first button in the error overlay
                 tryAgainButton.focus();
                 currentFocus = 'error'; // Special focus state
            }
            function hideError() { /* ... (minor change to restore focus) ... */
                errorOverlay.style.display = 'none';
                 // Restore focus to the appropriate area after closing error
                 if (currentFocus === 'player') {
                     focusPlayer();
                 } else {
                     focusPlaylist(); // Default back to playlist
                 }
            }

            // --- Status Update ---
            function updateChannelStatus(index, status) { /* ... (no changes) ... */
                if (index === null || index < 0 || index >= channels.length) return;
                console.log(`Updating status for index ${index} to ${status}`);
                channelStatuses[index] = status;
                localStorage.setItem(STATUS_STORAGE_KEY, JSON.stringify(channelStatuses));
                const listItem = playlist.querySelector(`li[data-original-index="${index}"]`);
                if (listItem) {
                    const dot = listItem.querySelector('.status-dot');
                    if (dot) {
                        dot.classList.remove('online', 'offline');
                        let statusTitle = 'Desconocido';
                        if (status === 'online') {
                            dot.classList.add('online');
                            statusTitle = 'En línea (última vez probado)';
                        } else if (status === 'offline') {
                            dot.classList.add('offline');
                            statusTitle = 'Fuera de línea (última vez probado)';
                        }
                        dot.title = `Estado: ${statusTitle}`;
                    }
                }
            }

            // --- Playlist Rendering ---
            function renderPlaylist(channelsToRender = channels) { /* ... (Add role and tabindex) ... */
                const currentFocusedElement = document.activeElement;
                const currentFocusedIndex = currentFocusedElement?.closest('li')?.dataset.originalIndex;
                const currentFocusedIsStar = currentFocusedElement?.classList.contains('star');

                playlist.innerHTML = ''; // Clear existing playlist

                if (!channelsToRender || channelsToRender.length === 0) {
                     if (countSpan) countSpan.textContent = '0';
                     if (currentChannelIndex === null && currentChannelTitleElement) {
                         currentChannelTitleElement.textContent = 'No hay canales';
                     }
                     const noChannelsMsg = document.createElement('li');
                     noChannelsMsg.textContent = searchInput.value ? 'No hay canales que coincidan.' : 'No hay canales para mostrar.';
                     noChannelsMsg.style.color = 'var(--text-secondary)';
                     noChannelsMsg.style.textAlign = 'center';
                     noChannelsMsg.style.marginTop = 'var(--spacing-l)';
                     playlist.appendChild(noChannelsMsg);
                    return;
                }

                if (countSpan) countSpan.textContent = channelsToRender.length;

                const sortedChannels = [...channelsToRender].sort((a, b) => {
                    const aIndex = channels.findIndex(ch => ch.url === a.url);
                    const bIndex = channels.findIndex(ch => ch.url === b.url);
                    const aIsFavorite = favorites.includes(aIndex.toString());
                    const bIsFavorite = favorites.includes(bIndex.toString());
                    if (aIsFavorite && !bIsFavorite) return -1;
                    if (!aIsFavorite && bIsFavorite) return 1;
                    if (a.title && b.title) {
                         return a.title.localeCompare(b.title, 'es', { sensitivity: 'base' });
                    }
                    return 0;
                });

                sortedChannels.forEach((channel) => {
                    const originalIndex = channels.findIndex(ch => ch.url === channel.url);
                    if (originalIndex === -1) return;

                    const li = document.createElement('li');
                    li.dataset.originalIndex = originalIndex;
                    li.setAttribute('role', 'option'); // ARIA role for list items
                    // li.tabIndex = -1; // Make LI focusable programmatically if needed, but focus children first

                    const channelButton = document.createElement('button');
                    channelButton.classList.add('channel-button');
                    channelButton.type = 'button';
                    channelButton.setAttribute('aria-label', `Reproducir ${channel.title || 'Canal sin título'}`);
                    channelButton.tabIndex = 0; // Make button focusable

                    const currentStatus = channelStatuses[originalIndex];
                    const statusTitle = currentStatus === 'online' ? 'En línea (última vez probado)' :
                                        currentStatus === 'offline' ? 'Fuera de línea (última vez probado)' :
                                        'Desconocido';
                    const logoSrc = channel.logo || `https://placehold.co/32x32/383838/A0A0A0?text=${encodeURIComponent((channel.title || '?').charAt(0))}`;
                    const logoAlt = channel.logo ? '' : `${channel.title || 'Canal'} Logo Placeholder`;

                    channelButton.innerHTML = `
                        <div class="channel-info">
                            <span class="status-dot ${currentStatus || ''}" title="Estado: ${statusTitle}"></span>
                            <img src="${logoSrc}" alt="${logoAlt}" onerror="this.onerror=null; this.src='https://placehold.co/32x32/383838/A0A0A0?text=${encodeURIComponent((channel.title || '?').charAt(0))}'; this.alt='${channel.title || 'Canal'} Logo Placeholder';" loading="lazy">
                            <div class="channel-details">
                                <span class="channel-title">${channel.title || 'Canal sin título'}</span>
                                <p class="channel-desc">${channel.descripcion || 'Sin descripción'}</p>
                            </div>
                        </div>`;

                    channelButton.addEventListener('click', () => {
                        selectChannel(originalIndex);
                         // When a channel is clicked, move focus to the player
                         focusPlayer();
                    });

                    li.appendChild(channelButton);

                    const star = document.createElement('i');
                    const isFavorite = favorites.includes(originalIndex.toString());
                    star.className = `star fas fa-star ${isFavorite ? 'favorite' : ''}`;
                    star.dataset.index = originalIndex;
                    star.setAttribute('role', 'button');
                    star.setAttribute('aria-pressed', isFavorite.toString());
                    star.setAttribute('aria-label', isFavorite ? `Quitar ${channel.title || 'Canal'} de favoritos` : `Añadir ${channel.title || 'Canal'} a favoritos`);
                    star.tabIndex = 0; // Make star focusable

                    star.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFavorite(originalIndex.toString());
                        const currentSearchTerm = searchInput.value.toLowerCase();
                        renderPlaylist(currentSearchTerm ? filterChannels(currentSearchTerm) : channels);
                        // Restore focus after re-render
                        restoreFocus(originalIndex.toString(), true); // Focus the star after toggling
                    });
                    star.addEventListener('keydown', (e) => {
                         if (e.key === 'Enter' || e.key === ' ') {
                             e.preventDefault();
                             e.stopPropagation();
                             toggleFavorite(originalIndex.toString());
                             const currentSearchTerm = searchInput.value.toLowerCase();
                             renderPlaylist(currentSearchTerm ? filterChannels(currentSearchTerm) : channels);
                             // Restore focus after re-render
                             restoreFocus(originalIndex.toString(), true); // Focus the star after toggling
                         }
                    });

                    li.appendChild(star);
                    playlist.appendChild(li);
                });

                 // Restore focus if possible after rendering
                 if (currentFocusedIndex !== undefined) {
                     restoreFocus(currentFocusedIndex, currentFocusedIsStar);
                 }

                // Apply active highlight if needed
                if (currentChannelIndex !== null && currentChannelIndex >= 0 && currentChannelIndex < channels.length) {
                    setActiveChannelHighlight(currentChannelIndex);
                }
            }

            // --- Focus Management ---
             function focusPlaylist() {
                 console.log("Focusing Playlist");
                 currentFocus = 'playlist';
                 playerContainer.blur(); // Ensure player loses focus appearance if needed

                 // Try to focus the first focusable item in the list, or the search bar, or the container
                 const firstButton = playlist.querySelector('li .channel-button');
                 const firstStar = playlist.querySelector('li .star');

                 if (searchInput.value === '' && (firstButton || firstStar)) {
                     (firstButton || firstStar).focus();
                 } else if (!searchInput.disabled) {
                     searchInput.focus();
                 } else {
                     playlistContainer.focus(); // Fallback to container
                 }
             }

             function focusPlayer() {
                 console.log("Focusing Player");
                 currentFocus = 'player';
                 searchInput.blur(); // Ensure search loses focus
                 // Focus the main player container (allows intercepting keys before controls)
                 // Or focus the video element directly if preferred
                 playerContainer.focus();
                 // videoPlayer.focus(); // Alternative
             }

             function restoreFocus(indexToRestore, focusStar = false) {
                 const targetLi = playlist.querySelector(`li[data-original-index="${indexToRestore}"]`);
                 if (targetLi) {
                     const targetElement = focusStar
                         ? targetLi.querySelector('.star')
                         : targetLi.querySelector('.channel-button');
                     if (targetElement) {
                         targetElement.focus();
                         return true; // Focus restored
                     }
                 }
                 return false; // Could not restore focus
             }

             function navigatePlaylist(direction) {
                 const focusableElements = Array.from(playlist.querySelectorAll('li .channel-button, li .star'));
                 if (focusableElements.length === 0) return; // No items to navigate

                 const currentFocusedElement = document.activeElement;
                 let currentIndex = focusableElements.findIndex(el => el === currentFocusedElement);

                 let nextIndex;
                 if (direction === 'down') {
                     nextIndex = (currentIndex === -1) ? 0 : (currentIndex + 1) % focusableElements.length;
                 } else { // direction === 'up'
                     nextIndex = (currentIndex <= 0) ? focusableElements.length - 1 : currentIndex - 1;
                 }

                 focusableElements[nextIndex].focus();
                 // Scroll the focused element into view smoothly
                 focusableElements[nextIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
             }


            // --- Filter Channels ---
             function filterChannels(searchTerm) { /* ... (no changes) ... */
                 if (!channels || channels.length === 0) return [];
                 const lowerSearchTerm = searchTerm.toLowerCase();
                 return channels.filter(ch =>
                     (ch.title && ch.title.toLowerCase().includes(lowerSearchTerm)) ||
                     (ch.descripcion && ch.descripcion.toLowerCase().includes(lowerSearchTerm))
                 );
             }

            // --- Set Active Highlight ---
            function setActiveChannelHighlight(index) { /* ... (no changes) ... */
                if (index === null || index < 0 || index >= channels.length) return;
                document.querySelectorAll('#playlist li').forEach(item => {
                    item.classList.remove('active');
                });
                const activeListItem = playlist.querySelector(`li[data-original-index="${index}"]`);
                if (activeListItem) {
                    activeListItem.classList.add('active');
                }
            }

            // --- Select Channel ---
            function selectChannel(index) { /* ... (Focus player after selection) ... */
                if (index === null || index === undefined || index < 0 || index >= channels.length) {
                    showError("Error interno: Índice de canal inválido.", index);
                    return;
                }
                hideError();
                const channel = channels[index];
                console.log(`Selecting channel ${index}: ${channel.title || 'Canal sin título'}`);

                if (currentChannelTitleElement) {
                    currentChannelTitleElement.textContent = channel.title || 'Canal sin título';
                    currentChannelTitleElement.title = channel.title || 'Canal sin título';
                }

                playVideo(channel.url, index);

                // Don't scroll player on TV, manage focus instead
                // scrollToPlayer(); // Removed for TV
                localStorage.setItem(LAST_PLAYED_STORAGE_KEY, index.toString());
                currentChannelIndex = index;
                setActiveChannelHighlight(index);
                // Focus the player after selection for immediate control
                focusPlayer();
            }

            // --- Play Video ---
             function playVideo(url, channelIndex) { /* ... (no changes needed in HLS logic) ... */
                 console.log(`Attempting to play URL: ${url} for channel index: ${channelIndex}`);
                 lastAttemptedChannel = channelIndex;

                 if (!url || typeof url !== 'string' || url.trim() === '') {
                     console.error("Invalid or missing URL for channel index:", channelIndex);
                     showError("URL del canal inválida o faltante en la lista M3U.", channelIndex);
                     return;
                 }

                 if (hls) { hls.destroy(); hls = null; }
                 videoPlayer.removeAttribute('src');
                 videoPlayer.load();
                 videoPlayer.removeEventListener('error', handleVideoElementError);
                 if (videoPlayingListener) { videoPlayer.removeEventListener('playing', videoPlayingListener); videoPlayingListener = null; }

                 const isM3U8 = url.includes('.m3u8') || url.includes('mpegurl');

                 const handlePlaying = () => {
                     if (lastAttemptedChannel === channelIndex) {
                         console.log(`Video playing event received for index ${channelIndex}.`);
                         updateChannelStatus(channelIndex, 'online');
                     }
                 };
                 videoPlayingListener = handlePlaying;

                 if (Hls.isSupported() && isM3U8) {
                     console.log("Using HLS.js for playback.");
                     hls = new Hls({});
                     hls.on(Hls.Events.ERROR, function(event, data) {
                         console.error('HLS.js Error:', event, data);
                         if (data.fatal) {
                             let errorMsg = `Error desconocido (${data.details}). Intente otro canal.`;
                             switch (data.type) {
                                 case Hls.ErrorTypes.NETWORK_ERROR: errorMsg = `Error de red (${data.details}). Verifique conexión e intente de nuevo.`; break;
                                 case Hls.ErrorTypes.MEDIA_ERROR: errorMsg = `Error en los datos del video (${data.details}). Intente otro canal.`; break;
                             }
                             if (lastAttemptedChannel === channelIndex) { showError(errorMsg, channelIndex); }
                             if (data.type === Hls.ErrorTypes.MEDIA_ERROR || data.type === Hls.ErrorTypes.OTHER_ERROR) { if (hls) hls.destroy(); hls = null; }
                         } else { console.warn('Non-fatal HLS Error:', data.details); }
                     });
                     hls.loadSource(url);
                     hls.attachMedia(videoPlayer);
                     hls.on(Hls.Events.MANIFEST_PARSED, function() {
                         console.log("HLS Manifest parsed. Attempting playback...");
                         videoPlayer.play().catch(e => { console.error("Error starting HLS playback:", e); });
                     });
                     videoPlayer.addEventListener('playing', videoPlayingListener, { once: true });

                 } else if (isM3U8 && videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                     console.log("Using native HLS support.");
                     videoPlayer.src = url;
                     videoPlayer.addEventListener('error', handleVideoElementError);
                     videoPlayer.addEventListener('loadedmetadata', () => {
                         console.log("Native HLS metadata loaded. Attempting playback...");
                         videoPlayer.play().catch(e => { console.error("Error starting native playback:", e); });
                     }, { once: true });
                     videoPlayer.addEventListener('playing', videoPlayingListener, { once: true });

                 } else {
                     console.warn("URL is not M3U8 or HLS is not supported/needed. URL:", url);
                     if (!isM3U8) {
                         console.log("Attempting direct playback for non-M3U8 URL.");
                         videoPlayer.src = url;
                         videoPlayer.addEventListener('error', handleVideoElementError);
                         videoPlayer.addEventListener('loadeddata', () => {
                             console.log("Direct video data loaded. Attempting playback...");
                             videoPlayer.play().catch(e => { console.error("Error starting direct playback:", e); });
                         }, { once: true });
                         videoPlayer.addEventListener('playing', videoPlayingListener, { once: true });
                     } else {
                         showError("Formato M3U8 no soportado por este navegador sin HLS.js.", channelIndex);
                     }
                 }
             }

            // --- Native Video Error Handler ---
             function handleVideoElementError() { /* ... (no changes) ... */
                 const error = videoPlayer.error;
                 if (!error || lastAttemptedChannel === null || lastAttemptedChannel >= channels.length) return;
                 console.error("Native <video> Element Error:", error);
                 let message = "Error desconocido al cargar el video.";
                 if (error) {
                     switch (error.code) {
                         case error.MEDIA_ERR_ABORTED: message = 'Carga de video abortada.'; break;
                         case error.MEDIA_ERR_NETWORK: message = 'Error de red al cargar video.'; break;
                         case error.MEDIA_ERR_DECODE: message = 'Error de decodificación de video.'; break;
                         case error.MEDIA_ERR_SRC_NOT_SUPPORTED: message = 'Formato no soportado o URL inválida.'; break;
                         default: message = `Error desconocido (código ${error.code}).`; break;
                     }
                 }
                 if (lastAttemptedChannel !== null) { showError(message, lastAttemptedChannel); }
                 videoPlayer.removeEventListener('error', handleVideoElementError);
             }

            // --- Scroll To Player (Removed for TV) ---
            // function scrollToPlayer() { ... }

            // --- Toggle Favorite ---
            function toggleFavorite(indexString) { /* ... (no changes) ... */
                 const index = parseInt(indexString);
                 if (isNaN(index)) return;
                 const indexInFavorites = favorites.indexOf(indexString);
                 if (indexInFavorites > -1) {
                     favorites.splice(indexInFavorites, 1);
                     console.log(`Removed channel index ${indexString} from favorites.`);
                 } else {
                     favorites.push(indexString);
                     console.log(`Added channel index ${indexString} to favorites.`);
                 }
                 localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(favorites));
            }

            // --- Error Button Listeners ---
            tryAgainButton.addEventListener('click', () => { /* ... (no changes) ... */
                hideError();
                if (lastAttemptedChannel !== null && lastAttemptedChannel >= 0 && lastAttemptedChannel < channels.length) {
                    selectChannel(lastAttemptedChannel);
                }
            });
            tryAnotherButton.addEventListener('click', () => { /* ... (no changes) ... */
                hideError();
                 // Focus back to playlist after closing error without retry
                 focusPlaylist();
            });
             reloadListButton.addEventListener('click', () => { /* ... (no changes) ... */
                 hideError();
                 initializeApp();
             });

            // --- Search Functionality ---
            searchInput.addEventListener('input', () => { /* ... (Focus handling needed) ... */
                const searchTerm = searchInput.value.toLowerCase().trim();
                renderPlaylist(filterChannels(searchTerm));
                // Keep focus on search input while typing
                searchInput.focus();
                currentFocus = 'playlist'; // Keep logical focus in playlist area
            });
             // Handle focus leaving search input
             searchInput.addEventListener('blur', () => {
                 // If focus moves outside playlist container, reset logical focus (though unlikely with D-pad)
                 if (!playlistContainer.contains(document.activeElement)) {
                     // currentFocus = null; // Or reset based on where focus went
                 }
             });
              searchInput.addEventListener('focus', () => {
                 currentFocus = 'playlist'; // Entering search means playlist area focus
             });


            // --- Keyboard Controls (Adapted for TV Remote) ---
            document.addEventListener('keydown', (event) => {
                console.log(`Keydown: Key='${event.key}', Code='${event.code}', keyCode='${event.keyCode}', Focus='${currentFocus}', ActiveElement=`, document.activeElement);

                // Don't interfere if user is typing in search
                if (document.activeElement === searchInput && event.key !== 'Enter' && event.key !== 'Escape' && event.key !== 'Backspace') {
                    return;
                }

                let preventDefault = true; // Prevent default unless needed

                // Handle Back button (common keyCodes: 8 for Backspace, 461 for some Samsung, 10009 for webOS)
                if (event.key === 'Backspace' || event.keyCode === 8 || event.keyCode === 461 || event.keyCode === 10009) {
                    event.preventDefault(); // Always prevent default for Back
                     if (currentFocus === 'error') {
                         // If error overlay is visible, 'Back' should close it (like tryAnotherButton)
                         hideError();
                         focusPlaylist(); // Go back to playlist after closing error
                     } else if (document.fullscreenElement) {
                         // Exit fullscreen if active
                         if (document.exitFullscreen) document.exitFullscreen();
                         else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                     } else if (currentFocus === 'player') {
                        // If focus is on player, move focus back to playlist
                        focusPlaylist();
                    } else if (document.activeElement === searchInput && searchInput.value !== '') {
                        // If search has text, allow backspace to delete text
                        preventDefault = false;
                    } else if (currentFocus === 'playlist') {
                        // Optional: Exit app or navigate back further? For now, do nothing more.
                        console.log("Back pressed in playlist - no action defined.");
                    }
                    return; // Back handled
                }

                // Handle based on current focused area
                if (currentFocus === 'playlist') {
                    switch (event.key) {
                        case 'ArrowUp':
                            if (document.activeElement === searchInput) {
                                // Move focus from search to last item in list
                                const focusable = Array.from(playlist.querySelectorAll('li .channel-button, li .star'));
                                if (focusable.length > 0) focusable[focusable.length - 1].focus();
                            } else {
                                navigatePlaylist('up');
                            }
                            break;
                        case 'ArrowDown':
                             if (document.activeElement === searchInput) {
                                // Move focus from search to first item in list
                                const firstFocusable = playlist.querySelector('li .channel-button, li .star');
                                if (firstFocusable) firstFocusable.focus();
                            } else {
                                navigatePlaylist('down');
                            }
                            break;
                        case 'ArrowRight':
                            // If focus is on a channel button, move to star (if exists)
                            if (document.activeElement?.classList.contains('channel-button')) {
                                const star = document.activeElement.closest('li')?.querySelector('.star');
                                if (star) star.focus();
                                else focusPlayer(); // If no star, maybe jump to player? Or stay.
                            } else {
                                // If focus is elsewhere in playlist (star, search), move to player
                                focusPlayer();
                            }
                            break;
                        case 'ArrowLeft':
                             // If focus is on a star, move to channel button
                             if (document.activeElement?.classList.contains('star')) {
                                const button = document.activeElement.closest('li')?.querySelector('.channel-button');
                                if (button) button.focus();
                            }
                            // If focus is on channel button or search, do nothing (stay in playlist)
                            break;
                        case 'Enter': // OK/Select button
                            if (document.activeElement === searchInput) {
                                // If search focused, maybe trigger search? Or focus first result?
                                // For now, focus first item.
                                const firstFocusable = playlist.querySelector('li .channel-button, li .star');
                                if (firstFocusable) firstFocusable.focus();
                            } else if (document.activeElement && typeof document.activeElement.click === 'function') {
                                // Simulate click on the focused element (button or star)
                                document.activeElement.click();
                            }
                            break;
                        default:
                            preventDefault = false; // Allow other keys if needed
                            break;
                    }
                } else if (currentFocus === 'player') {
                    switch (event.key) {
                        case 'ArrowUp':
                            // Volume Up
                            const vUp = Math.min(1, parseFloat((videoPlayer.volume + 0.1).toFixed(1)));
                            videoPlayer.volume = vUp; videoPlayer.muted = false;
                            break;
                        case 'ArrowDown':
                            // Volume Down
                            const vDown = Math.max(0, parseFloat((videoPlayer.volume - 0.1).toFixed(1)));
                            videoPlayer.volume = vDown; videoPlayer.muted = false;
                            break;
                        case 'ArrowRight':
                            // Seek Forward
                            videoPlayer.currentTime += 10; // Increase seek step for TV?
                            break;
                        case 'ArrowLeft':
                            // Seek Backward
                            videoPlayer.currentTime -= 10; // Increase seek step for TV?
                            break;
                        case 'Enter': // OK/Select button
                            // Play/Pause
                            if (videoPlayer.paused) videoPlayer.play().catch(e => console.error("Error playing:", e));
                            else videoPlayer.pause();
                            break;
                         case 'MediaPlayPause': // Handle remote play/pause button
                             if (videoPlayer.paused) videoPlayer.play().catch(e => console.error("Error playing:", e));
                             else videoPlayer.pause();
                             break;
                         case 'MediaStop': // Handle remote stop button
                             videoPlayer.pause();
                             videoPlayer.currentTime = 0;
                             break;
                         case 'MediaTrackNext': // Optional: Map next/prev track buttons
                             // selectNextChannel();
                             break;
                         case 'MediaTrackPrevious':
                             // selectPreviousChannel();
                             break;
                        // Mute (m), Fullscreen (f) can also be handled here if needed,
                        // but often TV handles volume/mute directly.
                        default:
                            preventDefault = false; // Allow other keys
                            break;
                    }
                 } else if (currentFocus === 'error') {
                     // Handle navigation within error buttons
                     switch (event.key) {
                         case 'ArrowRight':
                             if (document.activeElement === tryAgainButton) tryAnotherButton.focus();
                             else if (document.activeElement === tryAnotherButton && reloadListButton.style.display !== 'none') reloadListButton.focus();
                             else if (document.activeElement === reloadListButton) tryAgainButton.focus(); // Cycle back
                             break;
                         case 'ArrowLeft':
                             if (document.activeElement === tryAnotherButton) tryAgainButton.focus();
                             else if (document.activeElement === reloadListButton) tryAnotherButton.focus();
                             else if (document.activeElement === tryAgainButton && reloadListButton.style.display !== 'none') reloadListButton.focus(); // Cycle back
                             break;
                         case 'Enter': // OK/Select
                             if (document.activeElement && typeof document.activeElement.click === 'function') {
                                 document.activeElement.click();
                             }
                             break;
                         default:
                             preventDefault = false;
                             break;
                     }
                 } else {
                     // No specific focus area known, allow default
                     preventDefault = false;
                 }


                if (preventDefault) {
                    event.preventDefault();
                }
            });

            // --- Mouse Wheel Volume Control (Keep for Desktop/Web) ---
            playerContainer.addEventListener('wheel', (event) => { /* ... (no changes) ... */
                 if (playerContainer.contains(event.target) && !playlistContainer.contains(event.target)) {
                    event.preventDefault();
                    const volumeStep = 0.05;
                    let newVolume = event.deltaY < 0 ?
                        Math.min(1, parseFloat((videoPlayer.volume + volumeStep).toFixed(2))) :
                        Math.max(0, parseFloat((videoPlayer.volume - volumeStep).toFixed(2)));
                    videoPlayer.volume = newVolume;
                    videoPlayer.muted = false;
                 }
            }, { passive: false });

            // --- Initialization Function ---
            async function initializeApp() {
                channels = await fetchAndParseM3U(m3uUrl);
                renderPlaylist();

                if (channels.length > 0) {
                    const lastPlayedIndexStr = localStorage.getItem(LAST_PLAYED_STORAGE_KEY);
                    let initialChannelIndex = 0;
                    if (lastPlayedIndexStr !== null) {
                        const lastPlayedIndex = parseInt(lastPlayedIndexStr);
                        if (!isNaN(lastPlayedIndex) && lastPlayedIndex >= 0 && lastPlayedIndex < channels.length) {
                            initialChannelIndex = lastPlayedIndex;
                        } else {
                            localStorage.removeItem(LAST_PLAYED_STORAGE_KEY);
                        }
                    }
                    // Set initial state but don't play automatically
                     currentChannelIndex = initialChannelIndex;
                     setActiveChannelHighlight(initialChannelIndex);
                     if (currentChannelTitleElement) {
                        currentChannelTitleElement.textContent = channels[initialChannelIndex].title || 'Canal sin título';
                        currentChannelTitleElement.title = channels[initialChannelIndex].title || 'Canal sin título';
                     }
                     console.log(`Initial channel set to index: ${initialChannelIndex}`);
                     // Set initial focus to the playlist area
                     focusPlaylist();

                } else {
                    if (currentChannelTitleElement) currentChannelTitleElement.textContent = 'No hay canales';
                    console.log("Initialization complete, but no channels were loaded.");
                     searchInput.disabled = true;
                     playlistContainer.focus(); // Focus container if no channels/search
                     currentFocus = 'playlist';
                }
            }

            // --- Start the application ---
            initializeApp();

        }); // End DOMContentLoaded
    </script>
</body>
</html>
